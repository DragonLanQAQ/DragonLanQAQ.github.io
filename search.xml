<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java/wiki/MongoDB分片集群搭建步骤</title>
      <link href="/2022/07/17/java/wiki/mongodb-fen-pian-ji-qun-da-jian-bu-zou/"/>
      <url>/2022/07/17/java/wiki/mongodb-fen-pian-ji-qun-da-jian-bu-zou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MongoDB分片集群搭建步骤"><a href="#MongoDB分片集群搭建步骤" class="headerlink" title="MongoDB分片集群搭建步骤"></a>MongoDB分片集群搭建步骤</h1><h2 id="MongoDB-3-2及以下版本简单分片配置步骤"><a href="#MongoDB-3-2及以下版本简单分片配置步骤" class="headerlink" title="MongoDB 3.2及以下版本简单分片配置步骤"></a><a href="https://blog.csdn.net/m0_37294207/article/details/123646170" target="_blank" rel="noopener">MongoDB 3.2及以下版本简单分片配置步骤</a></h2><h2 id="MongoDB-3-2以上版本搭建步骤："><a href="#MongoDB-3-2以上版本搭建步骤：" class="headerlink" title="MongoDB 3.2以上版本搭建步骤："></a>MongoDB 3.2以上版本搭建步骤：</h2><blockquote><p>使用一个Replica Sets + Sharding的解决方案，对分片做集群。</p></blockquote><ul><li><p>Shard: 使用 Replica Sets，确保每个数据节点都具有备份、自动容错转移、自动恢复能力。</p></li><li><p>Config: 使用 3 个配置服务器，确保元数据完整性。</p></li><li><p>Route: 使用 3 个路由进程，实现负载平衡，提高客户端接入性能。</p></li></ul><h4 id="1、在测试之前，先简单描述一下本机测试环境的地址跟端口号，如下："><a href="#1、在测试之前，先简单描述一下本机测试环境的地址跟端口号，如下：" class="headerlink" title="1、在测试之前，先简单描述一下本机测试环境的地址跟端口号，如下："></a>1、在测试之前，先简单描述一下本机测试环境的地址跟端口号，如下：</h4><table><thead><tr><th></th><th>服务1</th><th>服务2</th><th>服务3</th><th></th></tr></thead><tbody><tr><td>shard1</td><td>127.0.0.1:27019</td><td>127.0.0.1:27119</td><td>127.0.0.1:27219</td><td>shard1的集群</td></tr><tr><td>shard2</td><td>127.0.0.1:27020</td><td>127.0.0.1:27120</td><td>127.0.0.1:27220</td><td>shard2的集群</td></tr><tr><td>config</td><td>127.0.0.1:27018</td><td>127.0.0.1:27118</td><td>127.0.0.1:27218</td><td>配置服务器的集群</td></tr><tr><td>route</td><td>127.0.0.1:27017</td><td>127.0.0.1:27117</td><td>127.0.0.1:27217</td><td>3个路由进程</td></tr></tbody></table><p>根据上面表格，服务2，服务3，是基于服务1的集群扩展。</p><h4 id="2、配置shard1"><a href="#2、配置shard1" class="headerlink" title="2、配置shard1"></a>2、配置shard1</h4><p>shard1的执行命令如下：</p><pre class=" language-shell"><code class="language-shell">mongod -shardsvr -replSet shard1 -port 27019 -dbpath=D:\MongoDB\data\db1mongod -shardsvr -replSet shard1 -port 27119 -dbpath=D:\MongoDB\data\db2mongod -shardsvr -replSet shard1 -port 27219 -dbpath=D:\MongoDB\data\db3</code></pre><p>启动完数据节点后，登录27019节点，添加副本集，操作如下：</p><pre class=" language-shell"><code class="language-shell">mongo -port 27019config={_id:'shard1',members:[{_id:0,host:'127.0.0.1:27019'},{_id:1,host:'127.0.0.1:27119'},{_id:2,host:'127.0.0.1:27219'}]}rs.initiate(config)</code></pre><h4 id="3、配置shard2"><a href="#3、配置shard2" class="headerlink" title="3、配置shard2"></a>3、配置shard2</h4><p>shard2的执行命令如下：</p><pre class=" language-shell"><code class="language-shell">mongod -shardsvr -replSet shard2 -port 27020 -dbpath=D:\MongoDB\data\db4mongod -shardsvr -replSet shard2 -port 27120 -dbpath=D:\MongoDB\data\db5mongod -shardsvr -replSet shard2 -port 27220 -dbpath=D:\MongoDB\data\db6</code></pre><p>启动完数据节点后，登录27020节点，添加副本集，操作如下：</p><pre class=" language-shell"><code class="language-shell">mongo -port 27020config={_id:'shard2',members:[{_id:0,host:'127.0.0.1:27020'},{_id:1,host:'127.0.0.1:27120'},{_id:2,host:'127.0.0.1:27220'}]}rs.initiate(config)</code></pre><h4 id="4、配置config"><a href="#4、配置config" class="headerlink" title="4、配置config"></a>4、配置config</h4><p>config的执行命令如下：</p><pre class=" language-shell"><code class="language-shell">mongod -configsvr -dbpath=D:\MongoDB\data\config1 -port 27018 -replSet config1mongod -configsvr -dbpath=D:\MongoDB\data\config2 -port 27118 -replSet config1mongod -configsvr -dbpath=D:\MongoDB\data\config3 -port 27218 -replSet config1</code></pre><p>登录其中一个节点，添加副本集，具体操作如shard1。</p><pre class=" language-shell"><code class="language-shell">mongo -port 27018config={_id:'config1',members:[{_id:0,host:'127.0.0.1:27018'},{_id:1,host:'127.0.0.1:27118'},{_id:2,host:'127.0.0.1:27218'}]}rs.initiate(config)</code></pre><h4 id="5、配置route"><a href="#5、配置route" class="headerlink" title="5、配置route"></a>5、配置route</h4><p>route的执行命令如下：</p><pre class=" language-shell"><code class="language-shell">mongos -configdb=config1/127.0.0.1:27018,127.0.0.1:27118,127.0.0.1:27218 -port 27017mongos -configdb=config1/127.0.0.1:27018,127.0.0.1:27118,127.0.0.1:27218 -port 27117mongos -configdb=config1/127.0.0.1:27018,127.0.0.1:27118,127.0.0.1:27218 -port 27217</code></pre><blockquote><p>注：-configdb要指定副本集的名字，在这里是config1</p></blockquote><p>登录其中一个节点，将shard添加进来，命令如下：</p><pre class=" language-shell"><code class="language-shell">mongo -port 27117 或 mongo -port 27217//得切换到admin数据库才能addshardmongos> use admin;switched to db admindb.runCommand({addshard:"shard1/127.0.0.1:27019,127.0.0.1:27119,127.0.0.1:27219"})db.runCommand({addshard:"shard2/127.0.0.1:27020,127.0.0.1:27120,127.0.0.1:27220"})</code></pre><p>之后，对需要进行分片的collection进行分片配置，在这里博主用test数据库的layne表做分片。</p><p>具体操作如下：</p><pre class=" language-shell"><code class="language-shell">db.runCommand({ enablesharding:"test" })db.runCommand({shardcollection:"test.layne",key:{_id:1}})   //制定shard key为：_id</code></pre><p>查看状态</p><pre class=" language-shell"><code class="language-shell">//切换到test数据库mongos> use testswitched to db testmongos> db.layne.stats(){        "sharded" : true,//设置分片成功        ......}</code></pre><h4 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h4><p>​        本文主要讲副本集+分片的集群搭建方式，先对分片，配置服务器做副本集，随后创建多个路由进程，实现负载平衡，提高客户端接入性能。</p><p>在测试过程中，需要注意的点就是分片的host的设置，不预先配置以127.0.0.1的IP，系统会默认用localhost。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/MongoDB安装</title>
      <link href="/2022/07/17/java/wiki/mongodb-an-zhuang/"/>
      <url>/2022/07/17/java/wiki/mongodb-an-zhuang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h1><h3 id="配置mongodb配置文件"><a href="#配置mongodb配置文件" class="headerlink" title="配置mongodb配置文件"></a>配置mongodb配置文件</h3><pre class=" language-shell"><code class="language-shell">mongod --dbpath D:\MongoDB\data\db</code></pre><p>创建<code>mongod.cfg</code>配置文件放置于<code>bin</code>文件夹下</p><pre class=" language-shell"><code class="language-shell">systemLog:    destination: file    logAppend: true    path: D:\MongoDB\data\log\mongod.logstorage:    dbPath: D:\MongoDB\data\db</code></pre><p>安装<code>MongoDB</code>服务</p><pre class=" language-shell"><code class="language-shell">mongod --config "D:\MongoDB\bin\mongod.cfg" --install </code></pre><p>在<code>DOS</code>窗口使用<code>mongod --version</code>验证是否安装成功</p><p>附：卸载<code>MongoDB</code>服务</p><pre class=" language-shell"><code class="language-shell">mongod --remove</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/logback 脱敏操作</title>
      <link href="/2022/07/17/java/wiki/logback-tuo-min-cao-zuo/"/>
      <url>/2022/07/17/java/wiki/logback-tuo-min-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="logback-脱敏操作"><a href="#logback-脱敏操作" class="headerlink" title="logback 脱敏操作"></a>logback 脱敏操作</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/kafka消费者端多线程消费的实现方案</title>
      <link href="/2022/07/17/java/wiki/kafka-xiao-fei-zhe-duan-duo-xian-cheng-xiao-fei-de-shi-xian-fang-an/"/>
      <url>/2022/07/17/java/wiki/kafka-xiao-fei-zhe-duan-duo-xian-cheng-xiao-fei-de-shi-xian-fang-an/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="kafka消费者端多线程消费的实现方案"><a href="#kafka消费者端多线程消费的实现方案" class="headerlink" title="kafka消费者端多线程消费的实现方案"></a>kafka消费者端多线程消费的实现方案</h1><h2 id="多线程方案："><a href="#多线程方案：" class="headerlink" title="多线程方案："></a>多线程方案：</h2><p>  我们要明确，kafkaConsumer类不是线程安全的。所有的网络I/O处理都发生在用户主线程中。所以，你使用时必须保证线程安全。也就是，你不能在多个线程中共享一个KafkaConsumer实例，否则会抛出ConcurrentModificationException异常。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/Kafka</title>
      <link href="/2022/07/17/java/wiki/kafka/"/>
      <url>/2022/07/17/java/wiki/kafka/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Kafka工厂配置</span><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"hrConsumerFactory"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> ConsumerFactory<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">hrConsumerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>BOOTSTRAP_SERVERS_CONFIG<span class="token punctuation">,</span> <span class="token function">hrDataPubKafkaBootStrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>MAX_POLL_RECORDS_CONFIG<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>MAX_POLL_INTERVAL_MS_CONFIG<span class="token punctuation">,</span> 60_000<span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>SESSION_TIMEOUT_MS_CONFIG<span class="token punctuation">,</span> 20_000<span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>ENABLE_AUTO_COMMIT_CONFIG<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>AUTO_COMMIT_INTERVAL_MS_CONFIG<span class="token punctuation">,</span> 10_000<span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>FETCH_MIN_BYTES_CONFIG<span class="token punctuation">,</span> <span class="token number">819200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>FETCH_MAX_WAIT_MS_CONFIG<span class="token punctuation">,</span> 10_000<span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>KEY_DESERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        config<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span>VALUE_DESERIALIZER_CLASS_CONFIG<span class="token punctuation">,</span> <span class="token string">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultKafkaConsumerFactory</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Kafka创建工厂</span><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"hrConsumerContainerFactory"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> KafkaListenerContainerFactory <span class="token function">hrConsumerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ConcurrentKafkaListenerContainerFactory<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentKafkaListenerContainerFactory</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setConsumerFactory</span><span class="token punctuation">(</span><span class="token function">hrConsumerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//监听设置分区数量 ?默认为1</span>        <span class="token comment" spellcheck="true">//factory.setConcurrency(concurrency);</span>        <span class="token comment" spellcheck="true">//打开批量拉取数据</span>        factory<span class="token punctuation">.</span><span class="token function">setBatchListener</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//配置手动提交offset</span>        factory<span class="token punctuation">.</span><span class="token function">getContainerProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAckMode</span><span class="token punctuation">(</span>ContainerProperties<span class="token punctuation">.</span>AckMode<span class="token punctuation">.</span>MANUAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-jav"><code class="language-jav">/**     * 监听kafka指定topic中对应的partitions     * @param records 接收到的消息     * 配置topic和分区：监听两个topic，分别为topic1、topic2，topic1只接收分区0，3的消息，     * topic2接收分区0和分区1的消息，但是分区1的消费者初始位置为5     */    @KafkaListener(containerFactory = "hrConsumerContainerFactory",topicPartitions =            { @TopicPartition(topic = "${spring.kafka.topic.topic1:action}", partitions = { "0","1", "2" }),                    @TopicPartition(topic = "${spring.kafka.topic.topic2:data}", partitions = "0",                            partitionOffsets = @PartitionOffset(partition = "1", initialOffset = "4"))            },groupId = "${spring.kafka.consumer.group-id:gaiaworks}",concurrency = "${spring.kafka.concurrency:2}")    public void onMessage(List<ConsumerRecord<String, String>> records,Acknowledgment acknowledgment){        try {            logger.info("【接收到消息】[线程ID:{} 消息内容：{}]", Thread.currentThread(), records);        }catch (Exception exception){            logger.error(exception.getMessage(), exception);        }finally {            acknowledgment.acknowledge();        }    }</code></pre><pre class=" language-java"><code class="language-java">#application<span class="token punctuation">.</span>propertiesspring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>servers<span class="token operator">=</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">9092</span>spring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>servers<span class="token operator">=</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">9092</span>spring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>bootstrap<span class="token operator">-</span>servers<span class="token operator">=</span>localhost<span class="token operator">:</span><span class="token number">9092</span>spring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>topic<span class="token punctuation">.</span>topic1<span class="token operator">=</span>actionspring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>topic<span class="token punctuation">.</span>topic2<span class="token operator">=</span>dataspring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>group<span class="token operator">-</span>id<span class="token operator">=</span>gaiaworks<span class="token operator">-</span>group#消费者的数量，不要大于分区数spring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>concurrency<span class="token operator">=</span><span class="token number">1</span>spring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>listener<span class="token punctuation">.</span>ack<span class="token operator">-</span>mode<span class="token operator">=</span>manualspring<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>client<span class="token operator">-</span>id<span class="token operator">=</span>Leon</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/Git基础操作</title>
      <link href="/2022/07/17/java/wiki/git-ji-chu-cao-zuo/"/>
      <url>/2022/07/17/java/wiki/git-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Git基础操作"><a href="#Git基础操作" class="headerlink" title="Git基础操作"></a>Git基础操作</h2><p><a href="https://www.cnblogs.com/liuwenlin/p/10213669.html" target="_blank" rel="noopener">Git笔记</a></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><p><img src="D:\笔记\Git区域.png" alt="Git区域"></p><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p><img src="D:\笔记\Git常用命令.png" alt="Git常用命令"></p><table><thead><tr><th><strong>git add .</strong></th><th><strong>添加当前目录的所有文件到暂存区</strong></th></tr></thead><tbody><tr><td><strong>git add <dir></strong></td><td><strong>添加指定目录到暂存区，包括子目录</strong></td></tr><tr><td><strong>git add <file1></strong></td><td><strong>添加指定文件到暂存区</strong></td></tr><tr><td><strong>git commit -m <message></strong></td><td><strong>提交暂存区到本地仓库,message代表说明信息</strong></td></tr><tr><td><strong>git commit <file1> -m <message></strong></td><td><strong>提交暂存区的指定文件到本地仓库</strong></td></tr><tr><td><strong>git commit –amend -m <message></strong></td><td><strong>使用一次新的commit，替代上一次提交</strong></td></tr><tr><td><strong>git branch</strong></td><td><strong>列出所有本地分支</strong></td></tr><tr><td><strong>git branch -r</strong></td><td><strong>列出所有远程分支</strong></td></tr><tr><td><strong>git branch -a</strong></td><td><strong>列出所有本地分支和远程分支</strong></td></tr><tr><td><strong>git branch <branch-name></strong></td><td><strong>新建一个分支，但依然停留在当前分支</strong></td></tr><tr><td><strong>git checkout -b <branch-name></strong></td><td><strong>新建一个分支，并切换到该分支</strong></td></tr><tr><td><strong>git branch –track <branch><remote-branch></strong></td><td><strong>新建一个分支，与指定的远程分支建立追踪关系</strong></td></tr><tr><td><strong>git checkout <branch-name></strong></td><td><strong>切换到指定分支，并更新工作区</strong></td></tr><tr><td><strong>git branch -d <branch-name></strong></td><td><strong>删除分支</strong></td></tr><tr><td><strong>git push origin –delete <branch-name></strong></td><td><strong>删除远程分支</strong></td></tr><tr><td><strong>git fetch <remote></strong></td><td><strong>merge之前先拉一下远程仓库最新代码</strong></td></tr><tr><td><strong>git merge <branch></strong></td><td><strong>合并指定分支到当前分支</strong></td></tr><tr><td><strong>git reset —soft <commit></strong></td><td>只改变提交点，暂存区和工作目录的内容都不改变</td></tr><tr><td><strong>git reset —mixed <commit></strong></td><td><strong>改变提交点，同时改变暂存区的内容</strong></td></tr><tr><td><strong>git reset —hard <commit></strong></td><td><strong>暂存区、工作区的内容都会被修改到与提交点完全一致的状态</strong></td></tr><tr><td><strong>git reset –hard HEAD</strong></td><td><strong>让工作区回到上次提交时的状态</strong></td></tr><tr><td><strong>git push</strong> <remote><branch></td><td>上传本地指定分支到远程仓库</td></tr><tr><td><strong>git push <remote> –force</strong></td><td><strong>强行推送当前分支到远程仓库，即使有冲突</strong></td></tr><tr><td><strong>git push <remote> –all</strong></td><td><strong>推送所有分支到远程仓库</strong></td></tr><tr><td><strong>git status</strong></td><td>显示有变更的文件</td></tr><tr><td><strong>git log</strong></td><td><strong>显示当前分支的版本历史</strong></td></tr><tr><td><strong>git diff</strong></td><td><strong>显示暂存区和工作区的差异</strong></td></tr><tr><td><strong>git diff HEAD</strong></td><td><strong>显示工作区与当前分支最新commit之间的差异</strong></td></tr><tr><td><strong>git cherry-pick <commit></strong></td><td><strong>选择一个commit，合并进当前分支</strong></td></tr></tbody></table><h2 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h2><p><strong>git init</strong></p><p>效果：</p><p>![git init效果](D:\笔记\git init效果.png)</p><p>注意：.git中存放的是本地库相关的子目录和文件，不要删除，也不要乱修改</p><pre><code>$ git initInitialized empty Git repository in D:/workspaces/GitTest/.git/</code></pre><h2 id="Git提交"><a href="#Git提交" class="headerlink" title="Git提交"></a>Git提交</h2><p>查看状态：git status</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/排序</title>
      <link href="/2022/07/17/java/wiki/pai-xu/"/>
      <url>/2022/07/17/java/wiki/pai-xu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/alan_liuyue/article/details/80740960" target="_blank" rel="noopener">排序</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><a href="https://so.csdn.net/so/search?q=%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020" target="_blank" rel="noopener">冒泡排序</a>是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6和4无需交换。5和3交换，变成3,5,4,8,6.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。</p><p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)</p><p><a href="https://so.csdn.net/so/search?q=%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020" target="_blank" rel="noopener">插入排序</a>不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。</p><p><strong>快速排序</strong></p><p>　　快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。快速排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。</p><p>举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。</p><p>5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</p><p>5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。</p><p>5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</p><p>4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</p><p>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</p><p>快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/命令行的相关操作</title>
      <link href="/2022/07/17/java/wiki/ming-ling-xing-de-xiang-guan-cao-zuo/"/>
      <url>/2022/07/17/java/wiki/ming-ling-xing-de-xiang-guan-cao-zuo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命令行的相关操作"><a href="#命令行的相关操作" class="headerlink" title="命令行的相关操作"></a>命令行的相关操作</h1><p>分片集群必须按照一定的顺序启动：config serve，Shard ，Mongos(Route)</p><pre class=" language-shell"><code class="language-shell">切换到D盘cd d:/cd Server/mongodb1/bincd d:/MongoDB/Server/mongodb1/bin切换到d盘d:mongodb的启动与停止net start mongodbnet stop mongodb</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/wiki/冷热数据</title>
      <link href="/2022/07/17/java/wiki/leng-re-shu-ju/"/>
      <url>/2022/07/17/java/wiki/leng-re-shu-ju/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是冷热数据"><a href="#什么是冷热数据" class="headerlink" title="什么是冷热数据"></a>什么是冷热数据</h1><p>Hot（热数据）</p><p>被频繁查询或更新</p><p>对访问的响应时间要求很高，通常在10毫秒以内</p><p>Cold（冷数据）</p><p>不允许更新，偶尔被查询</p><p>对访问的响应时间要求不高，通常在1~10秒内都可以接受</p><p><a href="https://blog.csdn.net/locahuang/article/details/112485334" target="_blank" rel="noopener">数据库优化整理之：冷热分离</a></p><h3 id="通过合理的冷热分离设计，可以达到的好处："><a href="#通过合理的冷热分离设计，可以达到的好处：" class="headerlink" title="通过合理的冷热分离设计，可以达到的好处："></a>通过合理的冷热分离设计，可以达到的好处：</h3><p>降低单表数据量，提升单表性能；<br>大量业务冷数据转冷存，存储成本可以降低很多，至少 50％＋。</p><h3 id="什么情况下使用冷热分离？"><a href="#什么情况下使用冷热分离？" class="headerlink" title="什么情况下使用冷热分离？"></a>什么情况下使用冷热分离？</h3><p>从冷热分离的定义我们可以知道当业务需求涉及到冷热数据，表数据量增长速度快或数据量较大时， 我们就该考虑是否使用冷热分离解决方案了。比如：<br>1）数据走到终态后，只有读没有写的需求。<br>2）用户能够接受新旧数据分开实现业务，比如查询新旧数据的时候分开操作。</p><h3 id="冷热分离解决方案的不足："><a href="#冷热分离解决方案的不足：" class="headerlink" title="冷热分离解决方案的不足："></a>冷热分离解决方案的不足：</h3><p>冷热分离确实可以在某种程度上解决写读写数据慢的问题，但是仍然存在诸多不足。具体表现有：<br>1）用户查询冷数据速度依旧很慢。<br>2）由于冷数据多到一定程度，业务就无法再修改冷数据，因为数据量太大系统承受不住。</p><h3 id="三种方式触发冷热数据分离："><a href="#三种方式触发冷热数据分离：" class="headerlink" title="三种方式触发冷热数据分离："></a>三种方式触发冷热数据分离：</h3><blockquote><ol><li><p>修改写操作的业务代码：</p><p>在代码中实现，当有对数据进行写操作时，触发冷热分离。</p><p>建议使用场景：业务代码比较简单，并且不按照时间区分冷热数据时使用。</p></li></ol></blockquote><blockquote><ol start="2"><li><p>监听数据库日志binlog变更：</p><p>监听数据库变更日志binlog的方式来触发。</p><p>建议使用场景：业务代码比较复杂，不敢随意变更，并且不按照时间区分冷热数据时使用。</p></li></ol></blockquote><blockquote><ol start="3"><li><p>定时扫描数据库：</p><p>通过定时扫描数据库的方式来触发。</p><p>建议使用场景：在按照时间区分冷热数据时使用。</p></li></ol></blockquote><p>​        </p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>全身追踪设置(tundra tracker)</title>
      <link href="/2022/05/20/you-xi/quan-shen-zhui-zong-she-zhi-tundra-tracker-pian/"/>
      <url>/2022/05/20/you-xi/quan-shen-zhui-zong-she-zhi-tundra-tracker-pian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="全身追踪设置（tundra-tracker）"><a href="#全身追踪设置（tundra-tracker）" class="headerlink" title="全身追踪设置（tundra tracker）"></a>全身追踪设置（tundra tracker）</h1><h2 id="1、先把steam设置为测试版本"><a href="#1、先把steam设置为测试版本" class="headerlink" title="1、先把steam设置为测试版本"></a>1、先把steam设置为测试版本</h2><p><img src="https://dragonlanqaq.gitee.io/imgs/%E6%B8%B8%E6%88%8F/steamVR%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%B5%8B%E8%AF%95%E7%89%88.png" alt="steamVR设置为测试版"></p><h2 id="2、进入steamVR目录"><a href="#2、进入steamVR目录" class="headerlink" title="2、进入steamVR目录"></a>2、进入steamVR目录</h2><p>打开steamVR目录，进入resources→setting文件夹，修改其中default.vrsettings文件</p><p><img src="https://dragonlanqaq.gitee.io/imgs/%E6%B8%B8%E6%88%8F/steamVR%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE.png" alt="steamVR默认设置"></p><p>“requireHmd”: true,改为”requireHmd”: false,</p><p>“activateMultipleDrivers”: false,改为”activateMultipleDrivers”: true,</p><p><img src="https://dragonlanqaq.gitee.io/imgs/%E6%B8%B8%E6%88%8F/%E4%BF%AE%E6%94%B9default.vrsetting%E6%96%87%E4%BB%B6.png" alt="修改default.vrsetting文件"></p><pre class=" language-tex"><code class="language-tex">"requireHmd": false,"activateMultipleDrivers": true,</code></pre><h2 id="3、下载安装OpenVR-SpaceCalibrator插件"><a href="#3、下载安装OpenVR-SpaceCalibrator插件" class="headerlink" title="3、下载安装OpenVR-SpaceCalibrator插件"></a>3、下载安装OpenVR-SpaceCalibrator插件</h2><p>下载地址：<a href="https://github.com/pushrax/OpenVR-SpaceCalibrator/releases" target="_blank" rel="noopener">https://github.com/pushrax/OpenVR-SpaceCalibrator/releases</a></p><p>一键式安装完成</p><p><img src="https://dragonlanqaq.gitee.io/imgs/%E6%B8%B8%E6%88%8F/OpenVR-SpaceCalibrator%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85.png" alt="OpenVR-SpaceCalibrator插件安装"></p>]]></content>
      
      
      <categories>
          
          <category> full body </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VR </tag>
            
            <tag> full body </tag>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常/料理</title>
      <link href="/2022/05/15/ri-chang/liao-li/"/>
      <url>/2022/05/15/ri-chang/liao-li/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="料理"><a href="#料理" class="headerlink" title="料理"></a>料理</h1><h2 id="红烧鸡翅尖"><a href="#红烧鸡翅尖" class="headerlink" title="红烧鸡翅尖"></a>红烧鸡翅尖</h2><ol><li>鸡翅尖冷水冲洗干净</li><li>凉水下锅，加入姜片和料酒去腥</li><li>开大火烧开后，漏勺捞出冲洗干净</li><li>锅中5勺油，放入鸡翅，中小火闭盖煎2~3分钟</li><li>半勺老抽，半勺盐，半勺糖，加入蒜蓉辣酱翻炒均匀</li><li>加入清水刚好没过翅尖，闭盖中火炖20分钟</li><li>转大火收汁(可加入葱花)</li><li>关火出锅</li></ol><h2 id="炖土豆块"><a href="#炖土豆块" class="headerlink" title="炖土豆块"></a>炖土豆块</h2><ol><li>土豆去皮切小块放入锅中</li><li>火腿切丁放入锅中</li><li>辣椒切块放入锅中</li><li>锅中加入一勺耗油、三勺生抽、半勺糖</li><li>闭盖中小火焖煮10分钟</li><li>开盖转大火收汁</li><li>可以撒葱</li></ol><h2 id="绿豆沙"><a href="#绿豆沙" class="headerlink" title="绿豆沙"></a>绿豆沙</h2><p>绿豆冷水冲洗干净</p><p>滤水，倒入开水，盖上盖子放置20分钟</p><p>放入冰箱冷冻6小时</p><p>冷冻完放入电饭煲</p><p>200g绿豆放矿泉水1.2L</p><p>煮粥模式煮2小时</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态创建RabbitMQ</title>
      <link href="/2022/04/26/java/rabbitmq/dong-tai-chuang-jian-rabbitmq/"/>
      <url>/2022/04/26/java/rabbitmq/dong-tai-chuang-jian-rabbitmq/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态创建RabbitMQ"><a href="#动态创建RabbitMQ" class="headerlink" title="动态创建RabbitMQ"></a>动态创建RabbitMQ</h1><pre><code>创建交换机:rabbitAdmin.declareExchange(fanoutExchange);删除交换机:rabbitAdmin.deleteExchange(exchangeName);创建队列:rabbitAdmin.declareQueue(queue);删除队列:rabbitAdmin.deleteQueue(queueName);绑定队列到对应交换机// 1.创建绑定关系对象        Binding binding =                BindingBuilder                        // 创建队列                        .bind(new Queue(queueName, true))                        // 创建交换机                        .to(new TopicExchange(exchange, true, false))                        // 指定路由 Key                        .with(&quot;order#&quot;);        // 2.进行绑定        rabbitAdmin.declareBinding(binding);        rabbitAdmin.declareBinding(BindingBuilder.bind(queue).to(fanoutExchange));取消交换机队列绑定:Binding binding = new Binding(queueName, Binding.DestinationType.QUEUE, exchange, &quot;order#&quot;, null);rabbitAdmin.removeBinding(binding);创建MQ连接：发送消息:private RabbitTemplate rabbitTemplate;rabbitTemplate.convertAndSend(queueName,message);停止MQ连接：</code></pre>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报错总结</title>
      <link href="/2022/04/25/java/bao-cuo-zong-jie/"/>
      <url>/2022/04/25/java/bao-cuo-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="报错总结"><a href="#报错总结" class="headerlink" title="报错总结"></a>报错总结</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>clone时提示要输入密码</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\报错\Git-Clone.png" alt="Git-Clone"></p><p>添加ssh密钥到git</p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/04/23/java/rabbitmq/rabbitmq/"/>
      <url>/2022/04/23/java/rabbitmq/rabbitmq/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ安装配置</p><h4 id="第一步：下载并安装erlang"><a href="#第一步：下载并安装erlang" class="headerlink" title="第一步：下载并安装erlang"></a>第一步：下载并安装erlang</h4><ul><li>原因：RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang。</li><li>下载地址：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">http://www.erlang.org/downloads</a></li></ul><h4 id="安装完事儿后要记得配置一下系统的环境变量。"><a href="#安装完事儿后要记得配置一下系统的环境变量。" class="headerlink" title="安装完事儿后要记得配置一下系统的环境变量。"></a>安装完事儿后要记得配置一下系统的环境变量。</h4><p>此电脑–&gt;鼠标右键“属性”–&gt;高级系统设置–&gt;环境变量–&gt;“新建”系统环境变量</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-1.png" alt="RabbitMQ-1"></p><p>变量名：ERLANG_HOME</p><p>变量值就是刚才erlang的安装地址，点击确定。</p><p>然后双击系统变量path</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-2.png" alt="RabbitMQ-2"></p><p>点击“新建”，将%ERLANG_HOME%\bin加入到path中。</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-3.png" alt="RabbitMQ-3"></p><ul><li>最后windows键+R键，输入cmd，再输入erl，看到版本号就说明erlang安装成功了。</li></ul><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-4.png" alt="RabbitMQ-4"></p><h4 id="第二步：下载并安装RabbitMQ"><a href="#第二步：下载并安装RabbitMQ" class="headerlink" title="第二步：下载并安装RabbitMQ"></a>第二步：下载并安装RabbitMQ</h4><ul><li><p>下载地址：<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html</a></p></li><li><p>双击下载后的.exe文件，安装过程与erlang的安装过程相同。</p></li><li><p>RabbitMQ安装好后接下来安装RabbitMQ-Plugins。打开命令行cd，输入RabbitMQ的sbin目录。</p></li></ul><p>我的目录是：D:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.3\sbin</p><p>然后在后面输入rabbitmq-plugins enable rabbitmq_management命令进行安装</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-5.png" alt="RabbitMQ-5"></p><p>打开命令行命令行,进入RabbitMQ的安装目录: sbin</p><p>,输入 rabbitmqctl status , 如果出现以下的图，说明安装是成功的，并且说明现在RabbitMQ Server已经启动了,运行正常。</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-6.png" alt="RabbitMQ-6"></p><p>打开sbin目录，双击rabbitmq-server.bat</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-7.png" alt="RabbitMQ-7"></p><p>等几秒钟看到这个界面后，访问<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672</a></p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-8.png" alt="RabbitMQ-8"></p><p>然后可以看到如下界面</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-9.png" alt="RabbitMQ-9"></p><p>默认用户名和密码都是guest</p><p>登陆即可。</p><p>安装步骤暂时就写这么多，本次安装是为了实现spring cloud的消息总线。后续用到了里面的具体内容和知识会再进行记录的。</p><h1 id="RabbitMQ使用与概念"><a href="#RabbitMQ使用与概念" class="headerlink" title="RabbitMQ使用与概念"></a>RabbitMQ使用与概念</h1><p>RabbitMQ作为一个消息中间件，其中设计思路基本都来源于AMQP协议，主要有如下几个重要的概念：</p><ul><li>Server：接收客户端的连接，实现AMQP实体服务。</li><li>Connection：连接，应用程序与Server的网络连接，TCP连接。</li><li>Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。</li><li>Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。</li><li>Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。</li><li>Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。</li><li>Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。</li><li>RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。</li><li>Queue：消息队列，用来保存消息，供消费者消费。</li></ul><p>主要分为三部分：</p><ul><li>生产者</li><li>消费者</li><li>服务端</li></ul><p>整个消息的发布与消费的流程大致如下：</p><ol><li>生产者client端指定服务端地址以及vhost虚拟主机，连接服务端</li><li>建立连接后，创建Channel信道，设置此信道的属性。</li><li>通过信道，声明交换机，队列，绑定关系，以及相关属性</li><li>通过信道，发送Message消息到Exchange交换机</li><li>交换机通过binding绑定关系与RoutingKey路由键，将消息分发到对应的Queue队列</li><li>消费者client通过服务端地址以及vhost连接服务端</li><li>建立连接后，创建信道，设置信道属性</li><li>通过信道，开启消费者监听队列，从队列中获取消息进行消费</li><li>根据是否延迟确认，确认消息已经被正常消费成功后，消息从队列中删除</li></ol><h3 id="Exchange交换机类型"><a href="#Exchange交换机类型" class="headerlink" title="Exchange交换机类型"></a>Exchange交换机类型</h3><p>注意：exchange负责消息路由，而不是存储，路由失败则消息丢失</p><h5 id="交换机的类型：Direct-exchange（直连交换机）、Fanout-exchange（扇型交换机）、Topic-exchange（主题交换机）、Headers-exchange（头交换机）、默认存在的交换机、Dead-Letter-Exchange（死信交换机）"><a href="#交换机的类型：Direct-exchange（直连交换机）、Fanout-exchange（扇型交换机）、Topic-exchange（主题交换机）、Headers-exchange（头交换机）、默认存在的交换机、Dead-Letter-Exchange（死信交换机）" class="headerlink" title="交换机的类型：Direct exchange（直连交换机）、Fanout exchange（扇型交换机）、Topic exchange（主题交换机）、Headers exchange（头交换机）、默认存在的交换机、Dead Letter Exchange（死信交换机）"></a>交换机的类型：Direct exchange（直连交换机）、Fanout exchange（扇型交换机）、Topic exchange（主题交换机）、Headers exchange（头交换机）、默认存在的交换机、Dead Letter Exchange（死信交换机）</h5><p>在上述结构中，生产者发送消息，并不是直接发送到队列的，而是发送到Exchange交换机，再由交换机分发到相应队列，没有匹配到队列则丢弃消息。根据Exchange的类型不同，可灵活实现常见的消息模式。</p><p>Exchange交换机共有四种类型：</p><ul><li>direct</li><li>fanout</li><li>topic</li><li>headers</li></ul><h4 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h4><p>Direct，完全匹配型交换机，此种类型交换机，通过RoutingKey路由键将交换机和队列进行绑定， 消息被发送到exchange时，需要根据消息的RoutingKey，来进行匹配，只将消息发送到完全匹配到此RoutingKey的队列。</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-10.png" alt="RabbitMQ-10"></p><p>如图，不同的key绑定不同的队列，实现不同消息分发至不同队列。</p><blockquote><p>PS: 注意同一个key，可以绑定多个queue队列。如图中，当匹配到key1时，则会将消息分发送至queue1和queue2，这样两个队列都会有相同的消息数据。</p></blockquote><h4 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h4><p>Fanout，扇出类型交换机，此种交换机，会将消息分发给所有绑定了此交换机的队列，此时RoutingKey参数无效。</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-11.png" alt="RabbitMQ-11"></p><p>此种方式，最简单快速，性能最好，因为少了中间的匹配判断环节。</p><h4 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h4><p>Topic，主题类型交换机，此种交换机与Direct类似，也是需要通过routingkey路由键进行匹配分发，区别在于Topic可以进行模糊匹配，Direct是完全匹配。<br>Topic中，将routingkey通过”.”来分为多个部分，通过如下功能字符来进行匹配：</p><ul><li>“*”：代表一个部分</li><li>“#”：代表一个或多个部分</li></ul><p>举个例子，加入绑定关系如下图：</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-12.png" alt="RabbitMQ-12"></p><p>然后发送一条信息，routingkey为”a.b.c.d”，那么根据”.”将这个路由键分为了4个部分，此条路由键，将会匹配：</p><ul><li>a.b.c. ：成功匹配，因为可以代表一个部分</li><li>a.b.# ：成功匹配，因为#可以代表一个或多个部分</li><li>a..c.. : 成功匹配，因为第一和第三部分分别为a和c，且为4个部分，刚好匹配</li><li>#.d ： 成功匹配，因为最后一个部分为d，前面所有部分被#代表了</li></ul><blockquote><p>PS：如果绑定的路由键为 “#” 时，则接受所有消息，因为路由键所有都匹配</p></blockquote><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><p>Headers，headers信息类型交换机，此类型交换机不通过routingkey路由键来分发消息，而是通过消息内容中的headers属性来进行匹配。headers类型交换器性能差，在实际中并不常用。</p><p>虽然不常用，但也可以了解一下其，此种交换机不通过routingkey，但是通过headers进行绑定，也就是在声明binding绑定关系时，需要传入需要匹配的header的key/value键值对。</p><p><img src="C:\Users\Dragon_Lan\blog\themes\matery\source\imgs\RabbitMQ\RabbitMQ-13.png" alt="RabbitMQ-13"></p><p>如图，绑定关系中，需要指定”x-match”匹配类型:</p><ul><li>all：需要所有的key-value都匹配，才能匹配成功</li><li>any：只需要其中一个key-value匹配，就匹配成功</li></ul><blockquote><p>PS: 不常用，此种方式性能比较差，如果要使用此种方式，使用前可进行性能测试，确保符合业务场景的需求</p></blockquote><p>原文连接：<a href="https://www.cnblogs.com/xingxia/p/rabbitmq_types.html" target="_blank" rel="noopener">RabbitMQ的四种交换机类型 https://www.cnblogs.com/xingxia/p/rabbitmq_types.html</a></p><h2 id="交换机的属性"><a href="#交换机的属性" class="headerlink" title="交换机的属性"></a>交换机的属性</h2><p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：</p><ul><li>Name：交换机名称</li><li>Durability：是否持久化。如果持久性，则RabbitMQ重启后，交换机还存在</li><li>Auto-delete：当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它</li><li>Arguments：扩展参数</li></ul><h1 id="RabbitListener注解消费消息"><a href="#RabbitListener注解消费消息" class="headerlink" title="@RabbitListener注解消费消息"></a>@RabbitListener注解消费消息</h1><h3 id="1-注解的字段"><a href="#1-注解的字段" class="headerlink" title="1 注解的字段"></a>1 注解的字段</h3><p><code>@RabbitListener</code>注解指定目标方法作为消费消息的方法，通过注解参数指定所监听的队列或者Binding。</p><h4 id="1-1-containerFactory"><a href="#1-1-containerFactory" class="headerlink" title="1.1 containerFactory"></a>1.1 containerFactory</h4><p>使用<code>@RabbitListener</code>的<code>containerFactory</code>可设置一个自己明确默认值的<code>RabbitListenerContainerFactory</code>对象。 <code>RabbitListenerContainerFactory</code>的bean名称用以创建负责服务于这个端点的消息监听器<a href="https://cloud.tencent.com/product/tke?from=10680" target="_blank" rel="noopener">容器</a>。 如果没有指定，使用默认的容器工厂。如果指定了，则返回其工厂bean名称。</p><h3 id="QueueBinding"><a href="#QueueBinding" class="headerlink" title="@QueueBinding"></a>@QueueBinding</h3><p>注意<code>@QueueBinding</code>注解的三个属性：</p><ul><li>value: @Queue 注解，用于声明队列，value 为 queueName, durable 表示队列是否持久化, autoDelete 表示没有消费者之后队列是否自动删除</li><li>exchange: @Exchange 注解，用于声明 exchange， type 指定消息投递策略，我们这里用的 topic 方式</li><li>key: 在 topic 方式下，这个就是我们熟知的 routingKey</li></ul>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行</title>
      <link href="/2022/04/20/java/ming-ling-xing/"/>
      <url>/2022/04/20/java/ming-ling-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命令行-CLI"><a href="#命令行-CLI" class="headerlink" title="命令行(CLI)"></a>命令行(CLI)</h1><h3 id="Dos命令"><a href="#Dos命令" class="headerlink" title="Dos命令"></a>Dos命令</h3><ul><li>cd</li><li>dir</li><li>md Java          创建一个名为Java的文件夹</li><li>mkdir</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bit与byte</title>
      <link href="/2022/04/20/java/bit-yu-byte/"/>
      <url>/2022/04/20/java/bit-yu-byte/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="bit-比特-与byte-字节"><a href="#bit-比特-与byte-字节" class="headerlink" title="bit(比特)与byte(字节)"></a>bit(比特)与byte(字节)</h1><p>一个0或者一个1存储为一个比特(bt)，是计算机中最小的存储单位。</p><p>计算机中是最基本的存储单元是字节(byte)。每个字节由8个比特构成。</p><h5 id="计算机的存储能力是以字节和多字节来衡量的。如下："><a href="#计算机的存储能力是以字节和多字节来衡量的。如下：" class="headerlink" title="计算机的存储能力是以字节和多字节来衡量的。如下："></a>计算机的存储能力是以字节和多字节来衡量的。如下：</h5><blockquote><p>千字节（kilobyte,KB）=1024B</p><p>兆字节（megabyte,MB）=1024KB</p><p>千兆字节（gigabyte.，GB）=1024MB</p><p>万亿字节（terabyte,TB）=1024GB</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bit </tag>
            
            <tag> byte </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据一致性</title>
      <link href="/2022/04/20/java/shu-ju-yi-zhi-xing/"/>
      <url>/2022/04/20/java/shu-ju-yi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h1><h2 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h2><p>在<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020" target="_blank" rel="noopener">分布式</a>系统中，一致性（Consistency）是指多副本（Replications）问题中的数据一致性。</p><h2 id="一致性的种类"><a href="#一致性的种类" class="headerlink" title="一致性的种类"></a>一致性的种类</h2><ul><li>事务一致性</li><li>数据一致性</li></ul><p>本文主要讨论数据一致性（事务一致性指ACID）</p><h2 id="导致一致性出现的原因"><a href="#导致一致性出现的原因" class="headerlink" title="导致一致性出现的原因"></a>导致一致性出现的原因</h2><ul><li>数据的分布式存储是导致出现一致性的唯一原因</li></ul><h2 id="强一致性-与-弱一致性"><a href="#强一致性-与-弱一致性" class="headerlink" title="强一致性 与 弱一致性"></a>强一致性 与 弱一致性</h2><p><strong>数据一致性的种类</strong></p><ul><li>强一致性（线性一致性）：即复制是同步的</li><li>弱一致性：即复制是异步的</li></ul><h3 id="强一致性两个要求"><a href="#强一致性两个要求" class="headerlink" title="强一致性两个要求"></a>强一致性两个要求</h3><ul><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。</li></ul><p>简言之，在任意时刻，所有节点中的数据是一样的。</p><h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。</p><p>最终一致性就属于弱一致性。</p><h3 id="强一致性和弱一致性举例"><a href="#强一致性和弱一致性举例" class="headerlink" title="强一致性和弱一致性举例"></a>强一致性和弱一致性举例</h3><p>例如，对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性<br>用户更新网站头像，在某个时间点，用户向主库发送更新请求，不久之后主库就收到了请求。在某个时刻，主库又会将数据变更转发给自己的从库。最后，主库通知用户更新成功。</p><p>如果在返回“更新成功”并使新头像对其他用户可见之前，主库需要等待从库的确认，确保从库已经收到写入操作，那么复制是同步的，即强一致性。如果主库写入成功后，不等待从库的响应，直接返回“更新成功”，则复制是异步的，即弱一致性。</p><p>强一致性可以保证从库有与主库一致的数据。如果主库突然宕机，我们仍可以保证数据完整。但如果从库宕机或网络阻塞，主库就无法完成写入操作。</p><p>在实践中，我们通常使一个从库是同步的，而其他的则是异步的。如果这个同步的从库出现问题，则使另一个异步从库同步。这可以确保永远有两个节点拥有完整数据：主库和同步从库。 这种配置称为半同步。</p><h2 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h2><p>两个要求：</p><ul><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>系统的所有进程的顺序一致，而且是合理的。即不需要和全局时钟下的顺序一致，错的话一起错，对的话一起对。（强一致性的要求比顺序一致性更严格）</li></ul><p><a href="https://lotabout.me/2019/QQA-What-is-Sequential-Consistency/" target="_blank" rel="noopener">顺序一致性参考</a></p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p>不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。</p><p>最终两个字用得很微妙，因为从写入主库到反映至从库之间的延迟，可能仅仅是几分之一秒，也可能是几个小时</p><ul><li>简单说，就是在一段时间后，节点间的数据会最终达到一致状态。</li></ul><h3 id="最终一致性的种类"><a href="#最终一致性的种类" class="headerlink" title="最终一致性的种类"></a>最终一致性的种类</h3><p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为：</p><ul><li>因果一致性（Casual Consistency）。如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问，遵守一般的最终一致性规则。</li><li>“读己之所写（read-your-writes）”一致性。当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</li><li>会话（Session）一致性。这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。</li><li>单调（Monotonic）读一致性。如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</li><li>单调写一致性。系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。</li></ul><p>原文链接：<a href="https://blog.csdn.net/a3125504x/article/details/109407748" target="_blank" rel="noopener">https://blog.csdn.net/a3125504x/article/details/109407748</a></p><h4 id="如何基于我们的MQ解决我们的分布式事务的问题-最终一致性"><a href="#如何基于我们的MQ解决我们的分布式事务的问题-最终一致性" class="headerlink" title="如何基于我们的MQ解决我们的分布式事务的问题(最终一致性)"></a>如何基于我们的MQ解决我们的分布式事务的问题(最终一致性)</h4><ol><li>确保我们的生产者往我们的MQ投递消息一定要成功.(生产者消息确认机制confirm),实现重试.</li><li>确保我们的消费者能够消费成功(手动ack机制),如果消费失败情况下,MQ自动帮消费者重试.</li><li>确保我们的生产者第一事务先执行成功,如果执行失败采用补单队列.</li></ol><p><img src="https://img-blog.csdnimg.cn/20200309142645379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nc2hlbmdxaWFuZzE2OA==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主数据相关概念</title>
      <link href="/2022/04/20/java/zhu-shu-ju/"/>
      <url>/2022/04/20/java/zhu-shu-ju/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主数据（MD）"><a href="#主数据（MD）" class="headerlink" title="主数据（MD）"></a>主数据（MD）</h1><h3 id="什么是主数据"><a href="#什么是主数据" class="headerlink" title="什么是主数据"></a>什么是主数据</h3><p>​        主数据，维基百科定义是在企业中用来定义业务对象的、具有持续性、非交易类的数据。相对于交易类数据，主数据是相对稳定的数据。</p><h3 id="主数据的特点"><a href="#主数据的特点" class="headerlink" title="主数据的特点"></a>主数据的特点</h3><p>​        主数据（Master Data）是具有共享性的基础数据，可以在企业内跨越各个业务部门被重复使用，处于相对高价值，高共享，相对稳定的状态。所以，主数据具有以下几个特征。</p><p><img src="https://dragonlanqaq.gitee.io/imgs/MasterData/%E4%B8%BB%E6%95%B0%E6%8D%AE-1.png" alt="主数据-1"></p><blockquote><p>  超越部门：主数据是组织范围内共享的、跨部门的数据，不归属某一特定的部门而归属于整个组织，是企业的核心数据资产。</p><p>  超越业务：主数据是跨越了业务界限，在多个业务领域中被广泛使用的数据，其核心属性也是来自业务。主数据在各个业务流程中都是唯一识别的对象，它不会依赖于业务流程存在，但它的价值是业务交互中体现的。</p><p>  超越系统：主数据是多个系统之间的共享数据，是应用系统建设的基础，同时也是数据分析系统重要的分析对象。因此，它应该保持相对独立，服务于但要高于其它业务信息系统。</p><p>  超越技术：主数据是要解决不同异构系统之间的核心数据共享问题，应当满足与不同业务系统架构下使用的情况，提供兼容多种系统架构，多兼容的数据接收及应用方式，不会局限于一种特定的技术。</p></blockquote><h3 id="主数据管理（MDM）"><a href="#主数据管理（MDM）" class="headerlink" title="主数据管理（MDM）"></a>主数据管理（MDM）</h3><p>​        主数据管理（MDM-Master Date Management）是把企业中多个业务系统中最核心最需要共享的数据进行整合，集中进行数据的清洗和标准化，最终通过主数据管理系统发送到各个需要使用这些数据的系统中去。</p><p>​        建立数据标准，实现数据集成、统一管控与无障碍共享。在这里需要强调一点的是:对主数据的管理要集中化、系统化、规范化。也就是说，主数据管理应保持相对独立，主数据管理系统是信息系统建设的基础，它服务于但是高于其它有业务信息系统。</p><h4 id="企业使用主数据管理系统的原因："><a href="#企业使用主数据管理系统的原因：" class="headerlink" title="企业使用主数据管理系统的原因："></a>企业使用主数据管理系统的原因：</h4><ol><li>在具有一定规模的企业中会同时使用多个系统，这些系统之间相互独立，互不干扰，系统间的数据会存在一物多码、一码多物的情况。</li><li>企业的各个子公司、分公司和部门之间的数据各自有各自的编码规则和命名规则，子公司、分公司甚至是部门之间的数据不能统一，企业获取到的数据质量太低。</li><li>数据难以协同、整合和共享，集成难度高，运营管理成本过高。</li></ol><h4 id="企业使用主数据管理系统意义："><a href="#企业使用主数据管理系统意义：" class="headerlink" title="企业使用主数据管理系统意义："></a>企业使用主数据管理系统意义：</h4><ol><li>在集团级统一了数据的编码规则和命名规则，减少一物多码和一码多物出现的概率。</li><li>可以通过主数据管理系统把数据推送到各个系统中，把系统中的数据来源、命名和编码规则规范。</li><li>数据集成、共享、协同程度高难度小，降低运营成本。</li><li>企业从各系统、子公司、分公司和部门获取到的数据准确，可用性高，提高了分析结果精确度。</li></ol><h4 id="主数据具有：特征唯一性、识别唯一性、长期有效性、业务稳定性"><a href="#主数据具有：特征唯一性、识别唯一性、长期有效性、业务稳定性" class="headerlink" title="主数据具有：特征唯一性、识别唯一性、长期有效性、业务稳定性"></a>主数据具有：特征唯一性、识别唯一性、长期有效性、业务稳定性</h4><ul><li>特征唯一性：在不同的应用和系统中有高度的一致性；</li><li>识别唯一性：在一个企业中，不分系统、部门都可以唯一识别出来；</li><li>长期有效性：长时间都是有效的数据，该业务对象贯穿于整个生命周期甚至更长；</li><li>业务稳定性：一旦录入系统中就很少fg改动，就像是人员的姓名、身份证号一样。</li></ul><h2 id="Master-Data-生命周期管理"><a href="#Master-Data-生命周期管理" class="headerlink" title="Master Data 生命周期管理"></a>Master Data 生命周期管理</h2><p>为了保证MasterData 它的生命周期内被有效管理和利用。MDM系统必须能提供以下类型的功能：</p><ol><li><p>从新建直到数据停用，MasterData均能在MDM系统得到管理。</p></li><li><p>能分组和定义MasterData 实体间的层次关系。</p></li><li><p>灵活管理不同MasterData domain间的复杂的关系。比如 产品VS供应商，客户VS账户和地理位置。</p></li><li><p>能定义MasterData间的层次、关系和分组。手工方式或者自动方式(从外部系统获得诸如公司和机构、人员和机构等之间的关系)</p></li><li><p> 有版本管理能力，能明白MasterData 实体的状态是如何随时间变化的，</p></li><li><p>有编写能力，能定义，管理，定制和扩展不同的类型的MasterData。</p></li><li><p>能够迅速增加新的MasterData。比如增加多渠道属性(multichannelattribute)，隐私偏好(Privacypreference)，还有存在但是尚未在企业应用中捕获的各种事件。多渠道属性可标记客户与企业最近一次交互的日期和时间，客户可能是通过客服代表，电话 或者Internet与企业接触的。隐私偏好标记客户的个人信息能不能在多个业务线间共享。</p></li><li><p> 支持多种层次结构。比如产品的分类：可以从购买者的角度分，也可以从销售的角度分。</p></li><li><p>能维护数据的来源，标记出与MDM系统中的Master Data实体相关联的MasterData的存储位置。MDM系统可能不存储所有的与Master Data实体相关的信息，仅包含了一些需要集中维护的属性。</p></li><li><p>必要的MDM安全和隐私机制。</p></li><li><p>必要的审计(Audit)功能，帮助管理员了解修改Master Data 的相关信息：“who,” “what,” “how,” and “when”。</p></li></ol><h2 id="数据质量管理"><a href="#数据质量管理" class="headerlink" title="数据质量管理"></a>数据质量管理</h2><ol><li><p>需要有作数据分析和概要 (analysis and profiling)的能力。这有利于了解源系统中MasterData的质量和结构，确认必要的清理和合并规则。数据概要(DataProfiling)能力提供了建立数据质量基线(baseline)的方法，用以评估Master data的质量的改进程度。</p></li><li><p>能基于一致的数据标准化、校验和清理逻辑 改进Master Data的数据质量。这要求定义和实施一致的数据清理和校验规则，为数据域指定标准化逻辑，比如姓名和地址。</p></li><li><p>数据调谐(Datareconciliation)：能自动调谐MasterData实体，比如：客户和产品。 要组合deterministic和probabilistic的匹配功能，定义在合并多个Master Data记录时的存留规则(survivorship rule)。</p></li><li><p> 数据治理能力：在发生数据冲突时，管理MasterData间的调谐，实施更新关键MasterData的数据质量策略。</p></li><li><p>能测量数据的失效程度(staleness)，定期更新和重新评估Master Data的数据质量。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Master Data </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Master Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常/软件安装相关</title>
      <link href="/2022/02/20/ri-chang/ruan-jian-an-zhuang-xiang-guan/"/>
      <url>/2022/02/20/ri-chang/ruan-jian-an-zhuang-xiang-guan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件安装相关"><a href="#软件安装相关" class="headerlink" title="软件安装相关"></a>软件安装相关</h2><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><ol><li>下载好jdk安装程序, 双击下载的exe文件，开始安装。如下图，点击下一步</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-1.jpg"></p><ol start="2"><li>选择jdk的安装目录，建议大家就算不使用默认路径，建议也放在C盘，纯英文的目录下</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-2.jpg"></p><ol start="3"><li>直接点击下一步，出现下图的告警信息，直接点“确定”，继续。</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-3.jpg"></p><ol start="4"><li>弹出个窗口，还要选择文件夹，不是安装程序出问题了，仔细一下，安装的不是jdk，是jre，jre是用于运行时的包，是jdk的一部分，所以继续安装，点击下一步</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-4.jpg"></p><ol start="5"><li>弹窗告诉已成功安装。如下图</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-5.jpg"></p><ol start="6"><li>接下来配置环境变量，在桌面右击“计算机”图标，选择“属性”。</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-6.jpg"></p><ol start="7"><li>点击高级系统设置，在“高级”选项卡，点击下方“环境变量”按钮，如下图选择新建</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-7.jpg"></p><ol start="8"><li>输入变量名：JAVA_HOME，　输入变量值：C:\Program Files\Java\jdk1.8.0_221 , 变量值为第3步中选择的安装路径</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-8.jpg"></p><ol start="9"><li>选择Path变量,选择编辑,如下图</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-9.jpg"></p><ol start="10"><li>选择新建,如下图</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-10.jpg"></p><ol start="11"><li>新建: %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;如下图,然后点击确定</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-11.jpg"></p><ol start="12"><li>继续在系统变量里面新建一个CLASSPATH变量，在第二栏一字不差地输入.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;（包括开头的”.”和结尾的”;”）。其变量值如下图所示：</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-12.jpg"></p><ol start="13"><li>WINDOWS+R键，输入cmd，进入命令行界面，如下所示：</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-13.jpg"></p><ol start="14"><li>输入java -version命令，可以出现如下图的提示，你可以看你安装的JDK版本。</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-14.jpg"></p><ol start="15"><li>输入javac命令可以出现如下的提示：</li></ol><p><img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-15.jpg"></p><ol start="16"><li>输入java命令就会出现如下图所示的结果</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/JDK/JDK-16.jpg"></p><h3 id="GIT安装"><a href="#GIT安装" class="headerlink" title="GIT安装"></a>GIT安装</h3><ol><li>查看 GNU 协议，可以直接点击下一步</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-1.jpg"></p><ol start="2"><li>选择Git安装路径</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-2.jpg"></p><ol start="3"><li>Git 选项配置，推荐默认设置，然后下一步。</li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-3.jpg"></p><ol start="4"><li><p>调整您的PATH环境</p><p>  第一种配置是“仅从Git Bash使用Git”。这是最安全的选择，因为您的PATH根本不会被修改。您只能使用 Git Bash 的 Git 命令行工具。但是这将不能通过第三方软件使用。</p><p>     第二种配置是“从命令行以及第三方软件进行Git”。该选项被认为是安全的，因为它仅向PATH添加了一些最小的Git包装器，以避免使用可选的Unix工具造成环境混乱。<br>  您将能够从Git Bash，命令提示符和Windows PowerShell以及在PATH中寻找Git的任何第三方软件中使用Git。这也是推荐的选项。</p><p>    第三种配置是“从命令提示符使用Git和可选的Unix工具”。警告：这将覆盖Windows工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。</p><p>    我选择推荐的选项第二种配置，点击“Next”按钮继续到下图的界面：</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-4.jpg"></p><ol start="5"><li><p>选择HTTPS后端传输</p><p>  第一个选项是“使用 OpenSSL 库”。服务器证书将使用ca-bundle.crt文件进行验证。这也是我们常用的选项。</p><p>     第二个选项是“使用本地 Windows 安全通道库”。服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书，例如通过Active Directory Domain Services 。</p><p>     我使用默认选项第一项，点击“Next”按钮继续到下图的界面：</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-5.jpg"></p><ol start="6"><li><p>配置行尾符号转换</p><p>第一个选项是“签出Windows风格，提交Unix风格的行尾”。签出文本文件时，Git会将LF转换为CRLF。提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Windows上的推荐设置（“ core.autocrlf”设置为“ true”）</p><p>   第二个选项是“按原样签出，提交Unix样式的行尾”。签出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Unix上的建议设置（“ core.autocrlf”设置为“ input”）</p><p>   第三种选项是“按原样签出，按原样提交”。当签出或提交文本文件时，Git不会执行任何转换。不建议跨平台项目选择此选项（“ core.autocrlf”设置为“ false”）</p><p>   我选择第一种选项，点击“Next”按钮继续到下图的界面：</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-6.jpg"></p><ol start="7"><li><p>配置终端模拟器以与Git Bash一起使用</p><p>第一个选项是“使用MinTTY（MSYS2的默认终端）”。Git Bash将使用MinTTY作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和Unicode字体。Windows控制台程序（例如交互式Python）必须通过“ winpty”启动才能在MinTTY中运行。</p><p>  第二个选项是“使用Windows的默认控制台窗口”。Git将使用Windows的默认控制台窗口（“cmd.exe”），该窗口可以与Win32控制台程序（如交互式Python或node.js）一起使用，但默认的回滚非常有限，需要配置为使用unicode 字体以正确显示非ASCII字符，并且在Windows 10之前，其窗口不能自由调整大小，并且只允许矩形文本选择。</p><p>  我选择默认的第一种选项，点击“Next”按钮继续到下图的界面：</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-7.jpg"></p><ol start="8"><li><p>配置配置额外的选项</p><p>第一个选项是“启用文件系统缓存”。文件系统数据将被批量读取并缓存在内存中用于某些操作（“core.fscache”设置为“true”）。 这提供了显著的性能提升。</p><p>  第二个选项是“启用Git凭证管理器”。Windows的Git凭证管理器为Windows提供安全的Git凭证存储，最显着的是对Visual Studio Team Services和GitHub的多因素身份验证支持。 （需要.NET Framework v4.5.1或更高版本）。</p><p>  第三个选项是“启用符号链接”。启用符号链接（需要SeCreateSymbolicLink权限）。请注意，现有存储库不受此设置的影响。</p><p>  我勾选默认的第一、第二选项，点击“Next”按钮继续到下图的界面：</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-8.jpg"></p><ol start="9"><li><p>安装完成</p><p>在这个界面，可以勾选是否启动启动Git Bash和是否查看发行说明，然后点“Finish”按钮退出安装界面。</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-9.jpg"></p><ol start="10"><li><p>启动测试</p><p>右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端。</p><p>在 Git Bash 终端里输入 git –version 查看 git 版本，如图所示，说明 Git 安装成功。</p></li></ol><p>​    <img src="https://dragonlanqaq.github.io/imgs/git/git-10.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日常/租房笔记</title>
      <link href="/2022/01/24/ri-chang/zu-fang-bi-ji/"/>
      <url>/2022/01/24/ri-chang/zu-fang-bi-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="租房笔记"><a href="#租房笔记" class="headerlink" title="租房笔记"></a>租房笔记</h2><p>大坑<br>1、黑中介（百福悦家）<br>要么找大中介，要么找房东直租<br>2.拒绝“二房东”（转租）<br>2、拒绝隔断间</p><p>细节<br>1.价格<br>2.地段（地铁站，公交站）距离须得自己实地考察<br>3.便利性（综合商场，小诊所，超市，菜市场，外卖，出租车等）<br>4.小区配套设施（封闭还是开放，有没有保安，进出刷卡否，绿化如何，一梯多少户）<br>5.房屋性质（城中村，回迁房，商住两用（注意是否商水商电））更细<br>1.楼层及位置（顶楼等电梯麻烦，还有漏水风险；一楼安全性有威胁，隐私性不好，蚊虫老鼠等；临街灰尘大，比较吵。）<br>2.朝向（南北朝向，南向房间比较贵，冬天室内温度有差异，北向冬冷夏热）<br>3.季节（夏天注意房顶漏水，有无返潮现象；冬天留意屋内温度）<br>4.杂费（物业费，取暖费，卫生费，注意一般是房东承担，记得落实到合同上，合租也要商量好）<br>5.网络需求（注意问清小区能不能接正规运营商的网络，回迁房就不能接）联通 电信</p><p>6.问题家具家电的处理（电视是否能放，床是否有塌陷，衣柜是否能开合，沙发有没有塌陷，热水器能不能正常洗澡）<br>7.有问题记得拍照当证据<br>8.水电交割（跟房东确认当前水量，燃气量，电表量，跟物业确认房东是否有正常缴纳物业费，否则冬天可能不给供暖）<br>9.看合同！！！（看清楚！房东及租户违约是什么规则，收租金的卡号写在合同里）<br>10.合租室友（随缘吧哈哈哈）<br>11.换锁芯！（买个新的几十块钱换上，旧的留着，退房的时候换回来）<br>12.退押金的问题（拼人品，调整好心态，能退多少都算赚哈哈哈，谁让租户是弱势群体呢。尽力争取就好，心态放平和，不要太在意啦。）</p><p>准备去苏州上班租房</p><p>自如：</p><p>链家：</p><p>让房东准备身份证、房产证复印件</p><p>提前确认项：</p><ol><li>水电费情况&amp;收费方式</li><li>可否养宠物</li><li>可否墙上打孔</li><li>租期时长</li><li>设施维修费用归属</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java/基础加强笔记</title>
      <link href="/2022/01/13/java/ji-chu-jia-qiang-bi-ji/"/>
      <url>/2022/01/13/java/ji-chu-jia-qiang-bi-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><ol><li>Junit单元测试</li><li>反射</li><li>注解</li></ol><h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><ul><li><p>测试分类：</p><ol><li>黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</li><li>白盒测试：需要写代码的。关注程序具体的执行流程。</li></ol></li><li><p>Junit使用：白盒测试</p><ul><li><p>步骤：</p><ol><li><p>定义一个测试类(测试用例)</p><ul><li>建议：<ul><li>测试类名：被测试的类名Test        CalculatorTest</li><li>包名：xxx.xxx.xx.test        cn.itcast.test</li></ul></li></ul></li><li><p>定义测试方法：可以独立运行</p><ul><li>建议：<ul><li>方法名：test测试的方法名        testAdd()  </li><li>返回值：void</li><li>参数列表：空参</li></ul></li></ul></li><li><p>给方法加@Test</p></li><li><p>导入junit依赖环境</p></li></ol></li><li><p>判定结果：</p><ul><li>红色：失败</li><li>绿色：成功</li><li>一般我们会使用断言操作来处理结果<ul><li>Assert.assertEquals(期望的结果,运算的结果);</li></ul></li></ul></li><li><p>补充：</p><ul><li>@Before:<ul><li>修饰的方法会在测试方法之前被自动执行</li></ul></li><li>@After:<ul><li>修饰的方法会在测试方法执行之后自动被执行</li></ul></li></ul></li></ul></li></ul><h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><ul><li>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</li><li>反射：将类的各个组成部分封装为其他对象，这就是反射机制<ul><li>好处：<ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol></li></ul></li></ul><ul><li><p>获取Class对象的方式：</p><ol><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li></ul></li><li>类名.class：通过类名的属性class获取<ul><li>多用于参数的传递</li></ul></li><li>对象.getClass()：getClass()方法在Object类中定义着。<ul><li>多用于对象的获取字节码的方式</li></ul></li></ol><ul><li>结论：<br>  同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul></li><li><p>Class对象功能：</p><ul><li><p>获取功能：</p><ol><li><p>获取成员变量们</p><ul><li><p>Field[] getFields() ：获取所有public修饰的成员变量</p></li><li><p>Field getField(String name)   获取指定名称的 public修饰的成员变量</p></li><li><p>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</p></li><li><p>Field getDeclaredField(String name)  </p></li></ul></li><li><p>获取构造方法们</p><ul><li><p>Constructor&lt;?&gt;[] getConstructors()  </p></li><li><p>Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)  </p></li><li><p>Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </p></li><li><p>Constructor&lt;?&gt;[] getDeclaredConstructors()  </p></li></ul></li><li><p>获取成员方法们：</p><ul><li><p>Method[] getMethods()  </p></li><li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li><li><p>Method[] getDeclaredMethods()  </p></li><li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li></ul></li><li><p>获取全类名    </p><ul><li>String getName()  </li></ul></li></ol></li></ul></li><li><p>Field：成员变量</p><ul><li><p>操作：</p><ol><li><p>设置值</p><ul><li>void set(Object obj, Object value)  </li></ul></li><li><p>获取值</p><ul><li>get(Object obj) </li></ul></li><li><p>忽略访问权限修饰符的安全检查</p><ul><li>setAccessible(true):暴力反射</li></ul></li></ol></li></ul></li></ul><ul><li><p>Constructor:构造方法</p><ul><li><p>创建对象：</p><ul><li><p>T newInstance(Object… initargs)  </p></li><li><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p></li></ul></li></ul></li><li><p>Method：方法对象</p><ul><li><p>执行方法：</p><ul><li>Object invoke(Object obj, Object… args)  </li></ul></li><li><p>获取方法名称：</p><ul><li>String getName:获取方法名</li></ul></li></ul></li><li><p>案例：</p><ul><li>需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法<ul><li>实现：<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤：<ol><li>将需要创建的对象的全类名和需要执行的方法定义在配置文件中</li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ol></li></ul></li></ul></li></ul><h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><ul><li><p>概念：说明程序的。给计算机看的</p></li><li><p>注释：用文字描述程序的。给程序员看的</p></li><li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></li><li><p>概念描述：</p><ul><li>JDK1.5之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li><li><p>作用分类：<br>  ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】<br>  ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>  ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</p></li><li><p>JDK中预定义的一些注解</p><ul><li>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</li><li>@Deprecated：该注解标注的内容，表示已过时</li><li>@SuppressWarnings：压制警告<ul><li>一般传递参数all  @SuppressWarnings(“all”)</li></ul></li></ul></li><li><p>自定义注解</p><ul><li><p>格式：<br>  元注解<br>  public @interface 注解名称{</p><pre><code>  属性列表;</code></pre><p>  }</p></li><li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li></ul></li><li><p>属性：接口中的抽象方法</p><ul><li><p>要求：</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li></ul></li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul></li></ul></li><li><p>在程序使用(解析)注解：获取注解中定义的属性值</p><ol><li>获取注解定义的位置的对象  （Class，Method,Field）</li><li>获取指定的注解<ul><li>getAnnotation(Class)<br>//其实就是在内存中生成了一个该注解接口的子类实现对象</li></ul><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Pro</span><span class="token punctuation">{</span>       <span class="token keyword">public</span> String <span class="token function">className</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token string">"cn.itcast.annotation.Demo1"</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">public</span> String <span class="token function">methodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token string">"show"</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre></li><li>调用注解中的抽象方法获取配置的属性值j</li></ol></li><li><p>案例：简单的测试框架</p></li><li><p>小结：</p><ol><li>以后大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用？<ol><li>编译器</li><li>给解析程序用</li></ol></li><li>注解不是程序的一部分，可以理解为注解就是一个标签</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/13/hello-world/"/>
      <url>/2022/01/13/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建步骤</title>
      <link href="/2022/01/10/bo-ke-de-da-jian-bu-zou/"/>
      <url>/2022/01/10/bo-ke-de-da-jian-bu-zou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="博客的搭建步骤"><a href="#博客的搭建步骤" class="headerlink" title="博客的搭建步骤"></a>博客的搭建步骤</h1><h2 id="Node-js的安装-https-nodejs-org-en"><a href="#Node-js的安装-https-nodejs-org-en" class="headerlink" title="Node.js的安装: https://nodejs.org/en/"></a>Node.js的安装: <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></h2><h4 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h4><p>node -v </p><p>npm -v</p><p>更换淘宝镜像源：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>cnpm -v</p><h4 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架:"></a>安装hexo框架:</h4><p>cnpm install -g hexo-cli</p><p>hexo -v</p><h4 id="创建博客目录："><a href="#创建博客目录：" class="headerlink" title="创建博客目录："></a>创建博客目录：</h4><p>mkdir blog</p><h4 id="进入博客目录："><a href="#进入博客目录：" class="headerlink" title="进入博客目录："></a>进入博客目录：</h4><p>cd blog</p><h4 id="初始化目录："><a href="#初始化目录：" class="headerlink" title="初始化目录："></a>初始化目录：</h4><p>hexo init</p><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h2><p>检查是否安装成功</p><p>git –version</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java应届生常见面试题</title>
      <link href="/2021/11/15/mian-shi/java-ying-jie-sheng-chang-jian-mian-shi-ti/"/>
      <url>/2021/11/15/mian-shi/java-ying-jie-sheng-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><p>String、StringBuffer、StringBuilder的区别：<a href="http://www.cnblogs.com/dolphin0520/p/3778589.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3778589.html</a></p><p>ArrayList、LinkedList区别：<a href="http://pengcqu.iteye.com/blog/502676" target="_blank" rel="noopener">http://pengcqu.iteye.com/blog/502676</a></p><p>HashTable、ConcurrentHashMap区别：<a href="http://blog.csdn.net/wisgood/article/details/19338693" target="_blank" rel="noopener">http://blog.csdn.net/wisgood/article/details/19338693</a></p><p>Collection和Collections的区别</p><p>equals方法和==的区别</p><p>银行家算法解决死锁问题：<a href="http://www.cnblogs.com/xuxu8511/archive/2012/04/06/2435053.html" target="_blank" rel="noopener">http://www.cnblogs.com/xuxu8511/archive/2012/04/06/2435053.html</a></p><p>TCP/IP原理：<a href="http://blog.csdn.net/jesseshen/article/details/6638914" target="_blank" rel="noopener">http://blog.csdn.net/jesseshen/article/details/6638914</a></p><p>TCP/IP 三次握手/四次挥手（注意传输的数据是什么）：<a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p><p>事务的ACID：<a href="http://blog.chinaunix.net/uid-7345847-id-2643947.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-7345847-id-2643947.html</a></p><p>事务隔离级别：<a href="http://www.cnblogs.com/lanhj/p/4601758.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanhj/p/4601758.html</a></p><blockquote><h3 id="String-和StringBuffer和-StringBuilder的区别？"><a href="#String-和StringBuffer和-StringBuilder的区别？" class="headerlink" title="String 和StringBuffer和 StringBuilder的区别？"></a>String 和StringBuffer和 StringBuilder的区别？</h3></blockquote><pre><code>           String 是字符串常量      StringBuffer 是字符串变量（线程安全）     StringBuilder 是字符串变量（非线程安全）</code></pre><p>String对象是一个不可被修改的字符串（内部用于存储的形式为private final char value[];），所以String是字符串常量。<br>StringBuffer和StringBuilder是“可变的字符串”（内部用于存储的形式为private char value[];），所以是字符串变量<br>而StringBuffer是线程安全的，StringBuilder是非线程安全的，因为StringBuffer的所有公开方法都是有synchronized修饰的同步方法</p><p>《深入理解Java虚拟机第三版》</p><blockquote><h3 id="sleep-区间wait-区间有什么区别？"><a href="#sleep-区间wait-区间有什么区别？" class="headerlink" title="sleep() 区间wait()区间有什么区别？"></a>sleep() 区间wait()区间有什么区别？</h3></blockquote><p>sleep是Thread对象的方法，wait是Object提供的方法<br>sleep使线程待指定时间，直到时间结束后恢复正常运行，不会释放任何资源（源码注释：The thread does not lose ownership of any monitors），如果该线程在持有锁的同步块中，其他线程无法抢占<br>wait的使用必须是在同步方法中，调用后将释放当前线程持有的锁资源，等待其他线程调用notify()或者notifyAll()方法将其唤醒</p><blockquote><h3 id="Object-中有哪些方法？其中clone-，怎么实现一个对象的克隆-Java如何实现深度克隆？"><a href="#Object-中有哪些方法？其中clone-，怎么实现一个对象的克隆-Java如何实现深度克隆？" class="headerlink" title="Object 中有哪些方法？其中clone()，怎么实现一个对象的克隆,Java如何实现深度克隆？"></a>Object 中有哪些方法？其中clone()，怎么实现一个对象的克隆,Java如何实现深度克隆？</h3></blockquote><p>1.object、getClass、wait、clone、notify、notifyAll、toString、hashCode<br>2.实现一个对象的克隆要使该对象实现Cloneable空接口，将Object中protected类型的clone方法重写为public类型。<br>3.深克隆是相对于“浅拷贝”只能拷贝对象中基本数据类型的参数而说的，其希望完全克隆对象中包含的引用数据类型，<br>3.1实现方式为在引用数据类型也实现Cloneable空接口并重写clone方法，在外层对象中调用<br>3.2或者使用序列化/反序列（实现Serializable接口）化手段进行深度克隆，可以借助Gson等序列化插件工具</p><blockquote><h3 id="与-equals的区别"><a href="#与-equals的区别" class="headerlink" title="==与 equals的区别"></a>==与 equals的区别</h3></blockquote><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//举例:</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a 为一个引用</span>        String b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// b为另一个引用,对象的内容一样</span>        String aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 放在常量池中</span>        String bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从常量池中查找</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aa==bb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false，非同一对象</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a==b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aEQb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// true</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><blockquote><h3 id="String-和-StringBuffer、StringBuilder-的区别是什么？String-为什么是不可变的？"><a href="#String-和-StringBuffer、StringBuilder-的区别是什么？String-为什么是不可变的？" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？"></a>String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？</h3></blockquote><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p><strong>线程安全性</strong></p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ol><blockquote><h3 id="接口和抽象类的区别是什么"><a href="#接口和抽象类的区别是什么" class="headerlink" title="接口和抽象类的区别是什么?"></a>接口和抽象类的区别是什么?</h3></blockquote><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法</li><li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li><li>一个类可以实现多个接口，但最多只能实现一个抽象类</li><li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定</li><li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ol><p>注意：Java8 后接口可以有默认实现( default )。</p><blockquote><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3></blockquote><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。<strong>也就是说方法提供的行为改变，而方法的外貌并没有改变。</strong></p><blockquote><h3 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h3></blockquote><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><blockquote><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3></blockquote><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p><h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h4><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiThread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取 Java 线程管理 MXBean</span>    ThreadMXBean threadMXBean <span class="token operator">=</span> ManagementFactory<span class="token punctuation">.</span><span class="token function">getThreadMXBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span>        ThreadInfo<span class="token punctuation">[</span><span class="token punctuation">]</span> threadInfos <span class="token operator">=</span> threadMXBean<span class="token punctuation">.</span><span class="token function">dumpAllThreads</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ThreadInfo threadInfo <span class="token operator">:</span> threadInfos<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"["</span> <span class="token operator">+</span> threadInfo<span class="token punctuation">.</span><span class="token function">getThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"] "</span> <span class="token operator">+</span> threadInfo<span class="token punctuation">.</span><span class="token function">getThreadName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> Attach Listener <span class="token comment" spellcheck="true">//添加事件</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> Signal Dispatcher <span class="token comment" spellcheck="true">// 分发处理给 JVM 信号的线程</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> Finalizer <span class="token comment" spellcheck="true">//调用对象 finalize 方法的线程</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> Reference Handler <span class="token comment" spellcheck="true">//清除 reference 线程</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> main <span class="token comment" spellcheck="true">//main 线程,程序入口</span></code></pre><p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p><blockquote><h3 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h3></blockquote><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3></blockquote><h4 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><blockquote><h3 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h3></blockquote><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li></ul><blockquote><h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3></blockquote><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><blockquote><h3 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h3></blockquote><p>●ListIterator有add()方法，可以向List中添加对象，而Iterator不能。</p><p>●ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</p><p>●ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</p><p>●都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</p><blockquote><h3 id="什么是三元运算符？"><a href="#什么是三元运算符？" class="headerlink" title="什么是三元运算符？"></a>什么是三元运算符？</h3></blockquote><p>三元运算符是 if-then-else 语句的一个替换，示例如下：</p><p>result = testStatement ? value1 : value2;</p><blockquote><h3 id="什么是垃圾回收？"><a href="#什么是垃圾回收？" class="headerlink" title="什么是垃圾回收？"></a>什么是垃圾回收？</h3></blockquote><p>垃圾回收（Garbage Collection，简称 GC）会查看堆内存，识别正在使用和未使用的对象，以及会自动删除未使用的对象，用来释放内存.</p><blockquote><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3></blockquote><p>按位与, a&amp;b 表示把a和b都转换成二进制数，再进行与的运算；</p><p>&amp;和&amp;&amp;都是逻辑运算符号，&amp;&amp;又叫短路运算符</p><p>逻辑与，a&amp;&amp; b ，a&amp;b 都表示当且仅当两个操作数均为 true时，其结果才为 true，否则为false。</p><p>逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true，整个表达式的值才是true。但是，&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p><blockquote><h3 id="Java中IO流分为几种"><a href="#Java中IO流分为几种" class="headerlink" title="Java中IO流分为几种?"></a>Java中IO流分为几种?</h3></blockquote><p>Java中的流分为两种：一种是字节流，另一种是字符流。</p><p>IO流分别由四个抽象类来表示（两输入两输出）:InputStream，OutputStream，Reader，Writer。</p><blockquote><h3 id="说说你熟悉的设计模式有哪些？"><a href="#说说你熟悉的设计模式有哪些？" class="headerlink" title="说说你熟悉的设计模式有哪些？"></a>说说你熟悉的设计模式有哪些？</h3></blockquote><p>设计模式分为三大类：</p><p>创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式（5种）</p><p>结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。（7种）</p><p>行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。（11种）</p><p>最好平时积累一下，单例模式（7种实现方式），工厂模式，模板方法设计模式，策略模式，装饰者模式、代理模式这几种怎么写吧~ </p><blockquote><h3 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h3></blockquote><p>实现 Cloneable 接口，重写 clone() 方法。</p><p>Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。</p><p>对象的属性的Class 也实现 Cloneable 接口，在克隆对象时也手动克隆属性，完成深拷贝</p><p>结合序列化(JDK java.io.Serializable 接口、JSON格式、XML格式等)，完成深拷贝</p><blockquote><h3 id="String-s-new-String-“xyz”-创建了几个String-Object"><a href="#String-s-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="String s = new String(“xyz”);创建了几个String Object?"></a>String s = new String(“xyz”);创建了几个String Object?</h3></blockquote><p>两个。第一个对象是字符串常量”xyz” 第二个对象是new String()的时候产生的，在堆中分配内存给这个对象，只不过这个对象的内容是指向字符串常量”xyz” 另外还有一个引用s，指向第二个对象。这是一个变量，在栈中分配内存。</p><blockquote><h6 id="变形①：String-s-“xyz”创建了几个String对象？"><a href="#变形①：String-s-“xyz”创建了几个String对象？" class="headerlink" title="变形①：String s = “xyz”创建了几个String对象？"></a>变形①：String s = “xyz”创建了几个String对象？</h6></blockquote><p>首先看常量池里有没有”xyz”，如果有直接引用，如果没有则创建再引用，这里”xyz”本身就是pool中的一个对象，而在运行时执行new String()时，将pool中的对象复制一份放到heap中，并且把heap中的这个对象的引用交给s持有。ok，这条语句就创建了2个String对象。</p><blockquote><h6 id="变形②：String-str-“aaa”-new-String-“bbb”-创建了几个String对象？"><a href="#变形②：String-str-“aaa”-new-String-“bbb”-创建了几个String对象？" class="headerlink" title="变形②：String str = “aaa” + new String(“bbb”)创建了几个String对象？"></a>变形②：String str = “aaa” + new String(“bbb”)创建了几个String对象？</h6></blockquote><p>四个， “aa”一个对象 new Sring()一个对象 “bbb”一个对象 “aa” + new String(“bbb”);一个对象</p><blockquote><h3 id="简述你所知道的Linux"><a href="#简述你所知道的Linux" class="headerlink" title="简述你所知道的Linux"></a>简述你所知道的Linux</h3></blockquote><p>　　Linux起源于1991年，1995年流行起来的免费操作系统，目前， Linux是主流的服务器操作系统， 广泛应用于互联网、云计算、智能手机(Android)等领域。由于Java主要用于服务器端的开发，因此Java应用的部署环境有很多为Linux。</p><p>　　Linux不像Windows的图形操作界面，是通过命令的方式进行操作，常用命令有：</p><pre><code>    1. pwd：用于显示当前工作目录;    2. ls：用于查看当前工作目录内容;    3. cd：用于改变当前工作目录。    4. mkdir：用于创建目录。    5. rm：用于删除一个文件或者目录。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门</title>
      <link href="/2021/11/03/java/spring/spring-ru-men/"/>
      <url>/2021/11/03/java/spring/spring-ru-men/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><blockquote><h4 id="Spring的开发步骤"><a href="#Spring的开发步骤" class="headerlink" title="Spring的开发步骤"></a>Spring的开发步骤</h4></blockquote><ol><li>导入坐标</li><li>创建<code>Bean</code></li><li>创建<code>applicationContext.xml</code></li><li>在配置文件中进行配置</li><li>创建<code>ApplicationContext</code>对象<code>getBean</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2021/11/02/mian-shi/java-mian-shi-ti/"/>
      <url>/2021/11/02/mian-shi/java-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><pre><code>1. String 和StringBuffer和 StringBuilder的区别？           String 是字符串常量 </code></pre><p>tringBuffer 是字符串变量（线程安全）<br>StringBuilder 是字符串变量（非线程安全）</p><p>String对象是一个不可被修改的字符串（内部用于存储的形式为private final char value[];），所以String是字符串常量。<br>StringBuffer和StringBuilder是“可变的字符串”（内部用于存储的形式为private char value[];），所以是字符串变量<br>而StringBuffer是线程安全的，StringBuilder是非线程安全的，因为StringBuffer的所有公开方法都是有synchronized修饰的同步方法</p><p>对String对象的拼接操作实则是使用StringBuffer的连续append操作，但是！自JDK5及以后的版本中对“锁机制”进行了优化，对字符串的加法操作会转化为StringBuilder的连续append<br>虚拟机对StringBuffer.append()的操作对象进行逃逸分析，如果该操作对象不会逃逸出当前方法，则会对append操作进行“锁消除”处理，再解释运行时这里仍会加锁，但经过编译之后会忽略所有同步锁直接执行</p><p>参考：<br><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247488178&amp;idx=1&amp;sn=e562f1904cd213b54fd6e1904d493b0f&amp;chksm=eb539784dc241e92cd3a91639b2e7eb3cb91f59f1d1ab75ffd4a521c16d965772dfa858bb19f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247488178&amp;idx=1&amp;sn=e562f1904cd213b54fd6e1904d493b0f&amp;chksm=eb539784dc241e92cd3a91639b2e7eb3cb91f59f1d1ab75ffd4a521c16d965772dfa858bb19f&amp;scene=21#wechat_redirect</a><br>《深入理解Java虚拟机第三版》</p><pre><code>2. sleep() 区间wait()区间有什么区别？</code></pre><p>sleep是Thread对象的方法，wait是Object提供的方法<br>sleep使线程待指定时间，直到时间结束后恢复正常运行，不会释放任何资源（源码注释：The thread does not lose ownership of any monitors），如果该线程在持有锁的同步块中，其他线程无法抢占<br>wait的使用必须是在同步方法中，调用后将释放当前线程持有的锁资源，等待其他线程调用notify()或者notifyAll()方法将其唤醒</p><pre><code>3. Object 中有哪些方法？其中clone()，怎么实现一个对象的克隆,Java如何实现深度克隆？</code></pre><p>1.object、getClass、wait、clone、notify、notifyAll、toString、hashCode<br>2.实现一个对象的克隆要使该对象实现Cloneable空接口，将Object中protected类型的clone方法重写为public类型。<br>3.深克隆是相对于“浅拷贝”只能拷贝对象中基本数据类型的参数而说的，其希望完全克隆对象中包含的引用数据类型，<br>3.1实现方式为在引用数据类型也实现Cloneable空接口并重写clone方法，在外层对象中调用<br>3.2或者使用序列化/反序列（实现Serializable接口）化手段进行深度克隆，可以借助Gson等序列化插件工具</p><p>ThreadLocal 相关<br><a href="https://www.cnblogs.com/dreamroute/p/5034726.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamroute/p/5034726.html</a><br>ThreadLocal 是 线程局部变量，其是“线程封闭”的一种实现手段，这个类能使线程中的某个值与保存值的对象关联起来。</p><pre><code>4. ThreadLocal作用和实现方式 ?</code></pre><p>1.作用：<br>1.1为每个使用ThreadLocal所保存变量的线程都存一份该变量的副本，防止对单例变量和全局变量进行共享。<br>1.2可以用来在线程中隐式传递参数。如某个线程中有方法的多级方法调用，而并非所有层级都会使用写带来的参数，此时可将参数存储于ThreadLocal中。</p><p>参考：<br><a href="https://www.zhihu.com/question/341005993" target="_blank" rel="noopener">https://www.zhihu.com/question/341005993</a><br><a href="http://www.majiang.life/blog/the-smart-way-of-passing-parameter-by-threadlocal/" target="_blank" rel="noopener">http://www.majiang.life/blog/the-smart-way-of-passing-parameter-by-threadlocal/</a><br>《Java 并发编程实战》 Brian Goetz</p><pre><code>ThreadLocal会不会发生内存泄漏?</code></pre><p>会存在内存泄漏，因为</p><pre><code>ThreadLocal为什么使用弱引用?5. InheritableThreadLocal作用和实现方式 ？</code></pre><p>InheritableThreadLocal用于父子线程之间的值传递，创建子线程时会将父线程InheritableThreadLocal的值给子线程。</p><pre><code>6. InheritableThreadLocal所带来的问题？</code></pre><p>1.InheritableThreadLocal在传递给子线程时，对于引用数据类型是传递引用，子线程对引用数据的修改会影响到父线程。<br>2.使用线程池时，线程执行完毕所在线程可能会保存复用，因此不再重新创建线程，因为InheritableThreadLocal值传递是在创建线程阶段，所以可能对导致传值失败</p><pre><code>7. 如何解决线程池异步值传递问题 (transmittable-thread-local)?</code></pre><p>阿里开源的transmittable-thread-local可以很好的解决 在线程池情况下,父子线程值传递问题;TransmittableThreadLocal继承了InheritableThreadLocal, 简单的原理就是TTL 中的holder持有的是当前线程内的所有本地变量,被包装的run方法执行异步任务之前，会使用replay进行设置父线程里的本地变量给当前子线程，任务执行完毕，会调用restore恢复该子线程原生的本地变量<br>即：执行前同步更新一下，执行后恢复一下</p><p>HashMap ConcurrentHashMap相关</p><pre><code>9. HashMap为什么线程不安全</code></pre><p>JDK1.7在多线程插入进行扩容操作时会有循环引用和数据丢失的风险。<br>JDK1.8之后多线程做PUT操作会有数据覆盖的风险<br>因为其操作并非原子操作</p><pre><code>10. HashMap在jdk7和8中的区别11. HashMap 为啥将链表改成红黑树？</code></pre><p>JDK7中采用数组+单链表的结构<br>JDK8中采用数组+链表+红黑树的数据结构，当链表长度达到8时，转为红黑树存储，降低查询的时间复杂度O(logN)提高了查询效率</p><pre><code>12. ConcurrentHashMap在jdk7和8中的区别?</code></pre><p>ConcurrentHashMap采用锁分段机制，细化了锁粒度，允许多线程并发对集合进行读写</p><pre><code>提到synchronized时候*,顺便说一下javaSE1.6对锁的优化？</code></pre><p>*synchronized 两大点：<br>1.synchronized修饰的同步块对同一个线程是可重入的（同一个线程反复进入同步块不会被锁死）<br>2.synchronized修饰的同步块 在持有锁的线程完全释放锁之前，其他线程只能阻塞等待。</p><pre><code>    轻量级锁    TODO 是锁优化的一个方案    重量级锁       Java线程的阻塞以及唤醒，都是依靠操作系统来完成的,这些操作将涉及系统调用，需要从操作系统 的用户态切换至内核态，其开销非常之大。</code></pre><p>如synchronize<br>其他优化<br>1.自旋（1.4就有了）与自适应旋转<br>减少线程切换带来的性能开销，对“简短”的线程有好处，自旋（实际上就是循环调用CAS算法的重试）期间不释放资源，所以不能长期自旋，1.6之前默认自旋10次，1.6之后引入了“自适应自旋”（参考锁拥有者状态和上一个线程自旋时间）<br>2.锁消除<br>经过逃逸分析算法确认在堆上的所有数据都不会逃逸出被其他线程访问。那就当做栈上数据（栈上数据是线程独立的）对待，认为是线程私有的，锁可以去除<br>3.锁粗化<br>如果一组操作反复对同一个对象加解锁（如StringBuffer的连续append）那么虚拟机会把枷锁操作扩展（粗化）到整个操作序列的外部 （说白了就是一起打包加锁，但前提是对同一个操作对象反复加解锁）<br>4.轻量级锁<br>TODO<br>5.偏向锁<br>TODO</p><pre><code>ReentrantLock和synchronized的区别？      相同点对同一条线程都是可重入的    Synchronized</code></pre><p>synchronize是重量级锁，其加解锁操作直接映射为操作系统对线程的操作，会导致从“用户态”到“内核态”之间的切换，从而造成资源浪费</p><pre><code>    ReentrantLock</code></pre><p>ReentrantLock是JDK5之后基于J.U.C包提供的Lock接口的实现*，相对于synchronize多了三个功能：<br>1.等待可中断：长期等待时可以选择放弃<br>2.公平锁：按照申请锁的时间顺序获得锁<br>3.锁定多个条件：synchronize 的wait、配合notify或notifyAll可以实现一个隐含条件，要想实现多个就必须反复上锁，ReentrantLock则只需要多次调用 new Condition()方法即可<br>synchronize是系统控制，出现异常也可释放锁，而ReentrantLock需要在finally中释放锁<br>*自从jdk5以后Java类库中提供了java.util.concurrent包其中的java.util.concurrent.locks.Lock接口，改为在类库层面实现同步，重入锁（ReentrantLock）是Lock接口最常见的实现。</p><pre><code>13. 为什么重写equals时候被要求重写hashCode（）？</code></pre><p>1.Object原生equals是采用==比较地址进行判断，重写equals是为了根据对象属性判断量对象属性是否相等<br>2..重写hashCode是因为集合存储中是先根据hash code判断对象是否存在，所以如果重写后的equals认为两对象属性相等，则应使用equals中作为判定条件的属性计算hash code</p><pre><code>14. 什么时候回发生内存泄露？让你写一段内存泄露的代码你会怎么写？</code></pre><p>1.内存泄漏指的是：一个不再会被使用到的对象没有被回收导致的内存占用<br>2.比如一个短生命周期的方法，使用了类对象中的属性，方法执行完毕，则对象属性理应被回收，而根绝GC垃圾回收算法，只有当该类无对象引用时才会清除，就造成了内存泄漏。<br>3.解决，手动将该对象置空 Object=null</p><p>Vector v = new Vector(10);<br>for (int i = 0; i &lt; 100; i++) {<br>Object o = new Object();<br>v.add(o);<br>o = null;<br>}<br>这里内部 Object o 虽然置为null 但外部Vector v仍然引用o 所以o不可被回收</p><p>Java多线程内存模型</p><p>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）</p><pre><code>Java 内存模型中的 happen-before 是什么？</code></pre><p>Java内存模型采用共享主内存的形式，在并发过程中围绕“原子性、可见性、有序性”三原则，而happen-before 就是对其有序性的顺序约束，如：将变量修改后同步到主内存，在变量读取前从主内存刷新变量，依靠此种happen-before的顺序操作来实现共享变量的可见性<br>参考：<br>《深入理解Java虚拟机》</p><pre><code>简单聊聊volatile 的特性？以及内存语义</code></pre><p>volatile有两项特性：<br>1.保证此变量对所有线程的可见性。即对volatile的写操作都能立刻反馈到其他线程中<br>2..保证此变量多线程下的读写原子性。读写原子性利用内存屏障禁止指令重排序优化<br>（但不能保证并发下的安全性，因为Java运算符不是原子操作，运算符最终会形成多条机器代码执行）</p><p>Java内存空间模型</p><p>GC垃圾回收</p><pre><code>垃圾回收主要是针对 内存区的哪些区域？</code></pre><p>堆内存：主要针对堆内存的新生代，大部分对象都是朝生夕灭的，针对新生代的回收性价比最高<br>方法区（次要）：方法区保存静态变量、常量、类型信息，在大量使用“反射、动态代理、CGLib等字节码框架”，这种频繁自定义类加载器的场景中有必要进行回收，《Java虚拟机规范》提到可以不针对该区域进行垃圾回收。</p><pre><code>垃圾检查有哪些算法？</code></pre><p>1.引用计数算法<br>2.可达性分析算法，以GCRoot根节点开始，以图论中的指向性分析可达性。“不可达”的将被清理</p><pre><code>垃圾回收方法有哪些？</code></pre><p>基于分代收集理论的算法有三种<br>1.标记-&gt;清除<br>2.标记-&gt;整理<br>3.标记-&gt;复制</p><pre><code>什么时候会触发Full GC</code></pre><p>当垃圾回收获得的可用空间不足以分配新建对象时</p><pre><code>**GC机制**简要说明一下，不同区使用的算法。</code></pre><p>新生代收集器：<br>Serial（客户端默认新生代）：复制算法，单线程回收,回收时暂停所有用户线程<br>ParNew（Serial的多线程）：复制算法，多线程并行回收，但回收时也会暂停所有用户线程<br>Parallel Scavenge（吞吐量）：复制算法，多线程并行回收，关注吞吐量（吞吐量=运行用户代码时间/处理器总消耗时间）,回收时暂停所有用户线程可控制停顿时间</p><p>老年代收集器：<br>Serial Old：标记整理，单线程回收，回收时暂停所有用户线程<br>Parallel Old：标记整理，多线程并行回收，回收时暂停所有用户线程吞吐量优先<br>CMS（短停顿）：标记清除（初始标记GCRoot直接引用暂停所有用户线程，并发标记引用链，重新标记做修正暂停所有用户线程，并发清除）</p><p>全区收集器：<br>G1：面向服务端,基于Region的内存划分，收集时间可控制，按受益大小回收。每个Region来看是“标记-复制”，宏观上是“标记-整理”</p><pre><code>两个对象循环引用会不会被被GC？</code></pre><p>要看GCRoot是否对其中的对象“可达”</p><pre><code>哪些可以算作根节点？</code></pre><p>栈中引用的对象（虚拟机栈、本地方法栈）<br>静态属性、常量引用的对象<br>被同步锁持有的对象<br>虚拟机内部引用的对象</p><pre><code>垃圾收集器 G1有什么样的特性了解吗？ CMS呢？</code></pre><p>G1是可预测停顿时间的全堆垃圾回收器<br>CMS是以获取最短停顿时间为目标的老年代收集器</p><pre><code>CMS收集器和G1收集器的区别</code></pre><p>区别一： 使用范围不一样<br>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用<br>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用<br>区别二： STW的时间<br>CMS收集器以最小的停顿时间为目标的收集器。<br>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）<br>区别三： 垃圾碎片<br>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片<br>G1收集器使用的是“标记-整理”算法，每个Region来看是“标记-复制”，进行了空间整合，降低了内存空间碎片。</p><p>Jvm相关</p><pre><code>Jvm内存结构简要说一些，栈里面一般存储了什么？Java内存模型简要描述一下?**类加载机制**简要描述一下?</code></pre><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。类加载和连接的过程都是在运行期间完成的。</p><pre><code>    类的加载方式</code></pre><p>类加载实际是对class文件的加载，class文件的存在形式包括但不限于，网络、数据库、内存、磁盘、动态生成、jar/zip包</p><pre><code>类加载的过程</code></pre><p>类加载的生命周期：<br>加载（Loading）–&gt;验证（Verification）–&gt;准备（Preparation）–&gt;解析（Resolution）–&gt;初始化（Initialization）–&gt;使用（Using）–&gt;卸载（Unloading）<br>加载（读取class）–&gt;验证（校验是否可用）–&gt;准备（分配内存）–&gt;解析（引用指向实体）–&gt;初始化（构造方法）–&gt;使用（调用）–&gt;卸载（卸载）</p><pre><code>JVM三种预定义类型类加载器    双亲委派加载    由不同的类加载器加载的指定类型还是相同的类型吗</code></pre><p>不是，JAVA中的类使用完全限定名标识，JVM中使用完全限定名+类加载器（ClassLoader）标识<br>equals() / isInstance()/ instanceof / isAssignableFrom的比较只有在同一个类加载器下才有意义</p><pre><code>    在代码中直接调用Class.forName（String name）方法，到底会触发那个类加载器进行类加载行为？</code></pre><p>Class.forName(String name)默认会使用调用类的类加载器来进行类加载</p><pre><code>    在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是?</code></pre><p>AppClassLoader</p><pre><code>    编写自定义类加载器时，一般有哪些注意点？</code></pre><p>一般尽量不要覆写已有的loadClass（…）方法中的委派逻辑; 这样做极有可能引起系统默认的类加载器不能正常工作</p><pre><code>    如何在运行时判断系统类加载器能加载哪些路径下的类？</code></pre><p>JDK9之前：获取到类加载器，调用ClassLoader.getURLs()<br>JDK9之后：引入java模块化系统，双亲委派关系发生变化。先判断要加载的类能否归属到一个模块，如果可以则委派给相应模块的类加载器加载。</p><pre><code>在Java的反射中，Class.forName和ClassLoader的区别</code></pre><p>Class.forName()也是使用ClassLoader实现类加载，里面调用forName0（）方法，initialize参数默认为true，即类加载时对其进行初始化操作（执行静态代码块、静态参数的赋值），而ClassLoader只是加载类到内存中<br><a href="https://www.cnblogs.com/jimoer/p/9185662.html" target="_blank" rel="noopener">https://www.cnblogs.com/jimoer/p/9185662.html</a></p><pre><code>Java 类加载机制及常见异常    ClassNotFoundException </code></pre><p>发生在加载阶段，原因是没有找到要加载的类，导致原因可能为Class.forName()参数写错，没有相应的jar包导入</p><pre><code> NoClassDefFoundError 通常在链接阶段</code></pre><p>发生在 链接 阶段；类生命周期有7个阶段：<br>加载-验证-准备-解析-初始化-使用-卸载<br>其中 “验证-准备-解析”统称为链接阶段</p><pre><code>Exception和Error的区别</code></pre><p>Exception是可捕获的异常，Error是不可预料的错误无法通过异常处理来进行逻辑处理</p><pre><code>平时有没有遇到一些栈溢出或者内存溢出，内存泄露的问题吗？如何去分析这个问题？</code></pre><p>栈：<br>如果线程请求的栈深度大于虚拟机所允许的最大深度时：StackOverFlowError<br>如果虚拟机内存的栈内存允许动态扩展，当栈容量无法申请到足够内存时：OutOfMemoryError<br>堆：<br>当堆内存无法满足对象的内存分配需要时：OutOfMemoryError<br>先确定错误类型，再确定报错区域（堆/栈/方法区/运行时常量池）<br>栈：查看是否有死循环调用<br>堆：使用内存快照分析工具，确定问题原因</p><pre><code>如果内存猛增，怎么去排查？</code></pre><p>使用分析工具jstack分析每个线程的内存占用</p><p>多线程</p><pre><code>为什么《阿里巴巴Java开发手册》强制不允许使用Executor创建线程池</code></pre><p>Executors创建出来的线程池使用的全都是无界队列，而使用无界队列会带来很多弊端，最重要的就是，它可以无限保存任务，因此很有可能造成OOM异常。</p><p>ThreadPoolExecutor机制</p><pre><code>下面是ThreadPoolExecutor最核心的构造方法参数：1）corePoolSize核心线程池的大小2）maximumPoolSize 最大线程池大小，当队列满了 就会创建新线程直至最大3）keepAliveTime 线程池中超过corePoolSize数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true)使得核心线程超出有效时间也关闭4）TimeUnit keepAliveTime的时间单位5）workQueue阻塞任务队列6）threadFactory新建线程工厂,可以自定义工厂7）RejectedExecutionHandler当提交任务数超过maximumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理</code></pre><p>重点讲解</p><pre><code>corePoolSize，maximumPoolSize，workQueue三者之间的关系1）当线程池小于corePoolSize时，新提交的任务会创建一个新线程执行任务，即使线程池中仍有空闲线程。2）当线程池达到corePoolSize时，新提交的任务将被放在workQueue中，等待线程池中的任务执行完毕3）当workQueue满了，并且maximumPoolSize &gt; corePoolSize时，新提交任务会创建新的线程执行任务4）当提交任务数超过maximumPoolSize，新任务就交给RejectedExecutionHandler来处理5）当线程池中超过 corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程6）当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</code></pre><p>RejectedExecutionHandler拒绝策略</p><pre><code>1、AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；2、CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；3、DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；4、DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；</code></pre><p>参考<br><a href="https://blog.csdn.net/qq_34436819/article/details/103207685?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242.0" target="_blank" rel="noopener">https://blog.csdn.net/qq_34436819/article/details/103207685?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242.0</a></p><pre><code>线程设置越多越好吗？设置到什么值比较合理？</code></pre><p>看业务具体定论</p><p>锁</p><pre><code>CAS实现机制？</code></pre><p>CAS实际是一个CPU指令：比较并交换，对一个值得修改操作要先取得该值，获取到的值与预估值如果一直，则进行赋值操作，如果不一致，则重新获取再次尝试</p><pre><code>CAS的ABA问题</code></pre><p>取到的值和预估值一样，但不排除从获取到比较之间该值有“变化再变回”的可能，但ABA问题并不影响操作结果，要避免可以使用java提供的原子操作，或使用互斥锁</p><p>算法</p><pre><code>有哪些常用的排序算法？插入排序、希尔排序、堆排序、归并排序、快速排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剖析⾯试最常⻅问题之Java集合框架</title>
      <link href="/2021/11/01/java/java-ji-chu-zhi-shi-pian/"/>
      <url>/2021/11/01/java/java-ji-chu-zhi-shi-pian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h4 id="Java集合概述"><a href="#Java集合概述" class="headerlink" title="Java集合概述"></a>Java集合概述</h4><p>集合概述 Java 集合概览 从下图可以看出，在 Java 中除了以 Map 结尾的类之外， 其他类都实现了 Collection 接⼝。 并且，以 Map 结尾的类都实现了 Map 接⼝。</p><p><img src="C:\Users\ll735\AppData\Roaming\Typora\typora-user-images\image-20211105192518597.png" alt="image-20211105192518597"></p><h4 id="说说List-Set-Map-三者的区别？"><a href="#说说List-Set-Map-三者的区别？" class="headerlink" title="说说List,Set,Map 三者的区别？"></a>说说List,Set,Map 三者的区别？</h4><ul><li><code>List</code> (对付顺序的好帮⼿): 存储的元素是有序的、可重复的。 </li><li><code>Set</code>(注重独⼀⽆⼆的性质): 存储的元素是⽆序的、不可重复的。 </li><li><code>Map</code> (⽤ Key 来搜索的专家): 使⽤键值对（<code>kye-value</code>）存储，类似于数学上的函数 y=f(x)， “x”代表 key，”y”代表 value，Key 是⽆序的、不可重复的，value 是⽆序的、可重复的，每个 键最多映射到⼀个值。</li></ul><h4 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h4><p>先来看⼀下 <code>Collection</code> 接⼝下⾯的集合。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><code>Arraylist </code>： Object[] 数组 </li><li><code>Vector</code> ： Object[] 数组 </li><li><code>LinkedList</code> ： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><code>HashSet</code> （⽆序，唯⼀）: 基于 <code>HashMap</code> 实现的，底层采⽤ <code>HashMap</code> 来保存元素 </li><li><code>LinkedHashSet</code> ： <code>LinkedHashSet</code> 是 <code>HashSet</code> 的⼦类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现⼀样，不过还是有⼀点点区别的 </li><li><code>TreeSet</code> （有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)</li></ul><p>再来看看 <code>Map</code> 接⼝下⾯的集合。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><code>HashMap</code> ： JDK1.8 之前 <code>HashMap</code>由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主 要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较⼤ 的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓ 度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以 减少搜索时间 </li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承⾃ <code>HashMap</code> ，所以它的底层仍然是基于拉链式散 列结构即由数组和链表或红⿊树组成。另外， <code>LinkedHashMap</code> 在上⾯结构的基础上，增加了 ⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作， 实现了访问顺序相关逻辑。详细可以查看：《<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener"><code>LinkedHashMap</code> 源码详细分析（JDK1.8）</a>》 </li><li><code>Hashtable</code> ： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突 ⽽存在的 </li><li><code>TreeMap</code> ： 红⿊树（⾃平衡的排序⼆叉树）</li></ul><h4 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h4><p>主要根据集合的特点来选⽤，⽐如我们需要根据键值获取到元素值时就选⽤ Map 接⼝下的集合，需 要排序时选择 <code>TreeMap</code> ,不需要排序时就选择 <code>HashMap</code> ,需要保证线程安全就选⽤ <code>ConcurrentHashMap</code> 。 </p><p>当我们只需要存放元素值时，就选择实现 <code>Collection</code> 接⼝的集合，需要保证元素唯⼀时选择实现 <code>Set</code> 接⼝的集合⽐如 <code>TreeSet</code> 或 <code>HashSet</code> ，不需要就选择实现 <code>List</code> 接⼝的⽐如 <code>ArrayList</code> 或 <code>LinkedList</code> ，然后再根据实现这些接⼝的集合的特点来选⽤。</p><h4 id="为什么要使⽤集合？"><a href="#为什么要使⽤集合？" class="headerlink" title="为什么要使⽤集合？"></a>为什么要使⽤集合？</h4><p>当我们需要保存⼀组类型相同的数据的时候，我们应该是⽤⼀个容器来保存，这个容器就是数组，但 是，使⽤数组存储对象具有⼀定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的， 于是，就出现了“集合”，集合同样也是⽤来存储多个数据的。 </p><p>数组的缺点是⼀旦声明之后，⻓度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数 据的类型；⽽且，数组存储的数据是有序的、可重复的，特点单⼀。 但是集合提⾼了数据存储的灵活 性，<code>Java</code> 集合不仅可以⽤来存储不同类型不同数量的对象，还可以保存具有映射关系的数据</p><h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h4><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//集合中是否还有元素</span>    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得集合中的下⼀个元素</span>    E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p><code>Iterator</code> 对象称为迭代器（设计模式的⼀种），迭代器可以对集合进⾏遍历，但每⼀个集合内部的 数据结构可能是不尽相同的，所以每⼀个集合存和取都很可能是不⼀样的，虽然我们可以⼈为地在每⼀ 个类中定义 <code>hasNext()</code> 和 <code>next()</code> ⽅法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。 </p><p>迭代器是将这样的⽅法抽取出接⼝，然后在每个类的内部，定义⾃⼰迭代⽅式，这样做就规定了整个集 合体系的遍历⽅式都是 <code>hasNext()</code> 和 <code>next()</code> ⽅法，使⽤者不⽤管怎么实现的，会⽤即可。迭代器的 定义为：提供⼀种⽅法访问⼀个容器对象中各个元素，⽽⼜不需要暴露该对象的内部细节。</p><h4 id="迭代器-Iterator-有啥用？"><a href="#迭代器-Iterator-有啥用？" class="headerlink" title="迭代器 Iterator 有啥用？"></a>迭代器 Iterator 有啥用？</h4><p><code>Iterator</code> 主要是⽤来遍历集合⽤的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元 素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><p>我们通过使⽤迭代器来遍历 <code>HashMap</code> ，演示⼀下 迭代器 Iterator 的使⽤。</p><pre class=" language-xml"><code class="language-xml">Map<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Integer,</span> <span class="token attr-name">String</span><span class="token punctuation">></span></span> map = new HashMap();map.put(1, "Java");map.put(2, "C++");map.put(3, "PHP");Iterator&lt;Map.Entry&lt;Integer, Stringef iterator =map.entrySet().iterator();while (iterator.hasNext()) {    Map.Entry<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Integer,</span> <span class="token attr-name">String</span><span class="token punctuation">></span></span> entry = iterator.next();    System.out.println(entry.getKey() + entry.getValue());}</code></pre><h4 id="有哪些集合是线程不安全的？怎么解决呢？"><a href="#有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="有哪些集合是线程不安全的？怎么解决呢？"></a>有哪些集合是线程不安全的？怎么解决呢？</h4><p>我们常⽤的 <code>Arraylist</code> , <code>LinkedList</code> , <code>Hashmap</code> , <code>HashSet</code> , <code>TreeSet</code> , <code>TreeMap</code> ， <code>PriorityQueue</code> 都不是线程安全的。 解决办法很简单，可以使⽤线程安全的集合来代替。 </p><p>如果你要使⽤线程安全的集合的话， java.util.concurrent 包中提供了很多并发容器供你使⽤： </p><ol><li><code>ConcurrentHashMap</code> : 可以看作是线程安全的 <code>HashMap</code> </li><li><code>CopyOnWriteArrayList</code> :可以看作是线程安全的 <code>ArrayList</code> ，在读多写少的场合性能⾮常 好，远远好于 <code>Vector</code> . </li><li><code>ConcurrentLinkedQueue</code> :⾼效的并发队列，使⽤链表实现。可以看做⼀个线程安全的 <code>LinkedList</code> ，这是⼀个⾮阻塞队列。 </li><li><code>BlockingQueue</code> : 这是⼀个接⼝，JDK 内部通过链表、数组等⽅式实现了这个接⼝。表示阻塞队列，⾮常适合⽤于作为数据共享的通道。 </li><li><code>ConcurrentSkipListMap</code> :跳表的实现。这是⼀个Map，使⽤跳表的数据结构进⾏快速查找。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Date数据类型</title>
      <link href="/2021/10/26/java/java-date-shu-ju-lei-xing/"/>
      <url>/2021/10/26/java/java-date-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java基础：Java-Date数据类型"><a href="#Java基础：Java-Date数据类型" class="headerlink" title="Java基础：Java Date数据类型"></a>Java基础：Java Date数据类型</h2><p>原文链接：<a href="https://blog.csdn.net/qq_26591517/article/details/81673488" target="_blank" rel="noopener">https://blog.csdn.net/qq_26591517/article/details/81673488</a></p><p> Java数据类型中Date数据类型在处理一些日常应用问题常常被人们使用。</p><p>然而在使用过程中许多人却没有真正的去了解有关于Java 数据类型中Date数据类型。</p><p>通常在这使用某一种数据类型过程中并不一定就会有哦相应的数据类型，往往存在各种各样的数据类型不断的更替转换。</p><h4 id="1-直接创建Date数据类型的实例变量date并直接将其输出："><a href="#1-直接创建Date数据类型的实例变量date并直接将其输出：" class="headerlink" title="1.直接创建Date数据类型的实例变量date并直接将其输出："></a>1.直接创建Date数据类型的实例变量date并直接将其输出：</h4><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * 创建Date类型的变量 this is date :Sat Dec 06 00:26:54 CST 2008     * 程序运行过程中直接将当前的时间打印出来     */</span>     Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is date :"</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="2-将直接实例化的Date数据以String的方式进行输出："><a href="#2-将直接实例化的Date数据以String的方式进行输出：" class="headerlink" title="2.将直接实例化的Date数据以String的方式进行输出："></a>2.将直接实例化的Date数据以String的方式进行输出：</h4><pre class=" language-java"><code class="language-java"><span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> 实例方法<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Sat Dec <span class="token number">06</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">26</span><span class="token operator">:</span><span class="token number">54</span> CST <span class="token number">2008</span> <span class="token operator">*</span> 其实效果也是和程序的直接输出一样只不过将输出的参数类型改变成为String的类型。 <span class="token operator">*</span><span class="token operator">/</span> String str_date <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is date_ str :"</span> <span class="token operator">+</span> str_date<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="3-采用DateFormat-方法格式化或者过滤所需要的数据参数："><a href="#3-采用DateFormat-方法格式化或者过滤所需要的数据参数：" class="headerlink" title="3.采用DateFormat()方法格式化或者过滤所需要的数据参数："></a>3.采用DateFormat()方法格式化或者过滤所需要的数据参数：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 方法 ：DateFormat.getInstance() 输出 ：08-12-6 上午12:26 * DateFormat()方法将日期格式化，格式输出到当前日的分上面。 */</span> String str_date_1 <span class="token operator">=</span> DateFormat<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is str_date_1 :"</span> <span class="token operator">+</span> str_date_1<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="4-采用SimpleDateFormat-方法格式化或者过滤所需要的数据参数："><a href="#4-采用SimpleDateFormat-方法格式化或者过滤所需要的数据参数：" class="headerlink" title="4.采用SimpleDateFormat()方法格式化或者过滤所需要的数据参数："></a>4.采用SimpleDateFormat()方法格式化或者过滤所需要的数据参数：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 方法 ：SimpleDateFormat() 输出 ：2008 12 06 00 26 54 * SimpleDateFormat()放法和DateFormat()类似他可以直接制定到当前日期的某一阶段 例如实例指定当前的秒钟。 */</span> SimpleDateFormat time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy MM dd HH mm ss"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is SimpleDateFormat :"</span> <span class="token operator">+</span> time<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="5-采用MessageFormat-方法格式化或者过滤所需要的数据参数："><a href="#5-采用MessageFormat-方法格式化或者过滤所需要的数据参数：" class="headerlink" title="5.采用MessageFormat()方法格式化或者过滤所需要的数据参数："></a>5.采用MessageFormat()方法格式化或者过滤所需要的数据参数：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 方法 : MessageFormat() 输出 ：2008-12-06-00-26:54:2654 */</span> String dateTime <span class="token operator">=</span> MessageFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span> <span class="token string">"{0,date,yyyy-MM-dd-HH-mm:ss:ms}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">new</span> <span class="token class-name">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>Date</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is Message datetime :"</span> <span class="token operator">+</span> dateTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/** * 方法 : MessageFormat() 输出 ：2008-12-06-00-26:54:2654 */</span> String dateTime <span class="token operator">=</span> MessageFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span> <span class="token string">"{0,date,yyyy-MM-dd-HH-mm:ss:ms}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">new</span> <span class="token class-name">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span>Date</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is Message datetime :"</span> <span class="token operator">+</span> dateTime<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="6-采用SimpleDateFormat-方法格式化或者过滤所需要的数据参数："><a href="#6-采用SimpleDateFormat-方法格式化或者过滤所需要的数据参数：" class="headerlink" title="6.采用SimpleDateFormat()方法格式化或者过滤所需要的数据参数："></a>6.采用SimpleDateFormat()方法格式化或者过滤所需要的数据参数：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 方法 : SimpleDateFormat() 输出 : 2008-12-06 * 类似于前面所讲到的SimpleDateFormat()方法、其实原理都是相同的只不过在处理过程中采用别的附加条件。 * */</span> SimpleDateFormat dateFm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 格式化当前系统日期 </span>String dateTime_1 <span class="token operator">=</span> dateFm<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is SimpleDateFormat :"</span> <span class="token operator">+</span> dateTime_1<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="7-采用DateFormat-方法格式化得到你所需要的Date参数："><a href="#7-采用DateFormat-方法格式化得到你所需要的Date参数：" class="headerlink" title="7.采用DateFormat()方法格式化得到你所需要的Date参数："></a>7.采用DateFormat()方法格式化得到你所需要的Date参数：</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 方法 ：DateFormat() * 通过DateFormat()方法所控制的不同参数来显示当前日期时间 */</span> <span class="token comment" spellcheck="true">//简略的将当前日期时间显示出来 </span>DateFormat shortDateFormat <span class="token operator">=</span> DateFormat<span class="token punctuation">.</span><span class="token function">getDateTimeInstance</span><span class="token punctuation">(</span> DateFormat<span class="token punctuation">.</span>SHORT<span class="token punctuation">,</span> DateFormat<span class="token punctuation">.</span>SHORT<span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>shortDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//精确地显示当前日期时间 </span>DateFormat mediumDateFormat <span class="token operator">=</span> DateFormat<span class="token punctuation">.</span><span class="token function">getDateTimeInstance</span><span class="token punctuation">(</span> DateFormat<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">,</span> DateFormat<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mediumDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//完全的将当前的日期时间显示出来 </span>DateFormat longDateFormat <span class="token operator">=</span> DateFormat<span class="token punctuation">.</span><span class="token function">getDateTimeInstance</span><span class="token punctuation">(</span> DateFormat<span class="token punctuation">.</span>LONG<span class="token punctuation">,</span> DateFormat<span class="token punctuation">.</span>LONG<span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>longDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//全部标准化的将当前日期时间按输出出来。 </span>DateFormat fullDateFormat <span class="token operator">=</span> DateFormat<span class="token punctuation">.</span><span class="token function">getDateTimeInstance</span><span class="token punctuation">(</span> DateFormat<span class="token punctuation">.</span>FULL<span class="token punctuation">,</span> DateFormat<span class="token punctuation">.</span>FULL<span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullDateFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="8-同时可以通过getTime-方法获取当前日期的时间："><a href="#8-同时可以通过getTime-方法获取当前日期的时间：" class="headerlink" title="8.同时可以通过getTime()方法获取当前日期的时间："></a>8.同时可以通过getTime()方法获取当前日期的时间：</h4><p>不过这样所得到的Date类型数据是以秒来计算的、并且是以1970年1月1日为开始的。在声明数据类型时需要较大存储空间使用Long数据类型或者同等存储类型数据。 </p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 方法 ： getTime() 输出 : 1228494414199 这个时间是按照1970年1月1日开始经历的毫秒数了、 */</span> <span class="token keyword">long</span> str_get <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"this is gettime :"</span> <span class="token operator">+</span> str_get<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>版权声明：本文为CSDN博主「ChasingdreamLY」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_26591517/article/details/81673488" target="_blank" rel="noopener">https://blog.csdn.net/qq_26591517/article/details/81673488</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter 选项详解</title>
      <link href="/2021/10/25/front-matter-xuan-xiang-xiang-jie/"/>
      <url>/2021/10/25/front-matter-xuan-xiang-xiang-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射_框架</title>
      <link href="/2021/10/23/java/fan-she-kuang-jia/"/>
      <url>/2021/10/23/java/fan-she-kuang-jia/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">//</span> <span class="token attr-value">pro.properties文件</span><span class="token attr-name">className</span> <span class="token punctuation">=</span> <span class="token attr-value">cn.itcast.domain.Person</span><span class="token attr-name">methodName</span> <span class="token punctuation">=</span> <span class="token attr-value">eat</span></code></pre><pre class=" language-JAVA"><code class="language-JAVA">public class ReflectTest{    public static void main(String[] args) throws Exception{        //可以创建任意类的对象，可以执行任意方法        //前提：不能改变任意类的任何代码                //1 加载配置文件，        //1.1 创建Properties对象        Properties pro = new Properties();                //1.2 加载配置文件，转换为一个集合        //1.2.1获取class目录下的配置文件        ClassLoader classLoader = ReflectTest.class.getClassLoader();        InputStream is = classLoader.getResourceAsStream("pro.properties");        pro.load(is);                //2 获取配置文件中定义的数据        String className = pro.getProperty("className");        String methodName = pro.getProperty("methodName");                //3 加载该类进内存        Class cls = Class.forName(className);                //4 创建对象        Object obj = cls.newInstance();                //5 获取方法对象        Method method = cls.getMethod(methodName);                //6 执行方法        method.invoke(obj);    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown快速入门(Typora)</title>
      <link href="/2021/10/22/markdown-kuai-su-ru-men-typora/"/>
      <url>/2021/10/22/markdown-kuai-su-ru-men-typora/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、代码块："><a href="#1、代码块：" class="headerlink" title="1、代码块："></a>1、代码块：</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//代码语法块（快捷键：CTRL+SHIFT+K）</span><span class="token comment" spellcheck="true">//用三个波浪号+代码语言（大小写均可）</span>```java    ```shell</code></pre><h5 id="1-java代码"><a href="#1-java代码" class="headerlink" title="1.java代码"></a>1.java代码</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>igeek<span class="token punctuation">.</span>client<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>igeek<span class="token punctuation">.</span>bean<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainSys</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Scanner in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//MenuSys.showMnueList(3);</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-shell脚本"><a href="#2-shell脚本" class="headerlink" title="2.shell脚本"></a>2.shell脚本</h5><pre class=" language-shell"><code class="language-shell">//linux下spring项目的启动命令# java -jar blog strat</code></pre><h2 id="2、标题"><a href="#2、标题" class="headerlink" title="2、标题"></a>2、标题</h2><pre class=" language-java"><code class="language-java"># 一级标题## 二级标题### 三级标题#### 四级级标题##### 五级标题###### 六级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级级标题"><a href="#四级级标题" class="headerlink" title="四级级标题"></a>四级级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="3、字体"><a href="#3、字体" class="headerlink" title="3、字体"></a>3、字体</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 斜体</span><span class="token operator">*</span>斜体字体<span class="token operator">*</span><span class="token comment" spellcheck="true">// 加粗</span><span class="token operator">*</span><span class="token operator">*</span>加粗字体<span class="token operator">*</span><span class="token operator">*</span><span class="token comment" spellcheck="true">// 代码高亮</span><span class="token operator">==</span>高亮字体<span class="token operator">==</span>    <span class="token comment" spellcheck="true">// 删除线</span><span class="token operator">~</span><span class="token operator">~</span>删除线字体<span class="token operator">~</span><span class="token operator">~</span>    <span class="token comment" spellcheck="true">// 下划线</span><span class="token operator">&lt;</span>u<span class="token operator">></span>下划线字体<span class="token operator">&lt;</span><span class="token operator">/</span>u<span class="token operator">></span>        Ctrl <span class="token operator">+</span> B <span class="token operator">:</span>加粗Ctrl <span class="token operator">+</span> I <span class="token operator">:</span>斜体Ctrl <span class="token operator">+</span> U <span class="token operator">:</span>下划线Ctrl <span class="token operator">+</span> K <span class="token operator">:</span>超链接Ctrl <span class="token operator">+</span> \ <span class="token operator">:</span>清除样式Ctrl <span class="token operator">+</span> shift <span class="token operator">+</span> ` <span class="token operator">:</span>高亮代码Alt  <span class="token operator">+</span> shift <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">:</span>删除线</code></pre><p><em>斜体字体</em></p><p><strong>加粗字体</strong></p><p>==高亮字体==</p><p><u>下划线字体</u></p><p><code>高亮代码</code></p><p><del>删除线字体</del></p><h2 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 引用语法</span><span class="token operator">></span>一级引用<span class="token operator">>></span>二级引用<span class="token operator">>>></span>三级引用    </code></pre><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用 </p></blockquote></blockquote></blockquote><h2 id="5、分割线"><a href="#5、分割线" class="headerlink" title="5、分割线"></a>5、分割线</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分割线</span><span class="token operator">--</span><span class="token operator">-</span><span class="token comment" spellcheck="true">//分割线2</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span></code></pre><hr><hr><h2 id="6、图片插入"><a href="#6、图片插入" class="headerlink" title="6、图片插入"></a>6、图片插入</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在线图片（快捷键：CTRL+SHIFT+I）</span><span class="token operator">!</span><span class="token punctuation">[</span>照片描述<span class="token punctuation">]</span><span class="token punctuation">(</span>图片链接<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//本地图片</span><span class="token operator">!</span><span class="token punctuation">[</span>照片描述<span class="token punctuation">]</span><span class="token punctuation">(</span>图片地址<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//![我的照片](/image/me.png) --图片路径</span></code></pre><p><img src="https://dragonlanqaq.gitee.io/medias/avatar.jpg" alt="我的头像"></p><h2 id="7、超链接"><a href="#7、超链接" class="headerlink" title="7、超链接"></a>7、超链接</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 超链接语法（快捷键：CTRL+K）</span><span class="token punctuation">[</span>Gitee<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>gitee<span class="token punctuation">.</span>com<span class="token operator">/</span>DragonLanQAQ<span class="token punctuation">)</span></code></pre><p>这是我的<a href="https://gitee.com/DragonLanQAQ" target="_blank" rel="noopener">Gitee</a>地址</p><h2 id="8、列表"><a href="#8、列表" class="headerlink" title="8、列表"></a>8、列表</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 无序列表</span><span class="token operator">-</span> 目录<span class="token number">1</span><span class="token operator">-</span> 目录<span class="token number">2</span><span class="token operator">-</span> 目录<span class="token number">3</span><span class="token comment" spellcheck="true">// 有序列表 1 +. + 名称   </span><span class="token comment" spellcheck="true">// 有序列表 序号+点+空格</span><span class="token comment" spellcheck="true">// 列表嵌套按tab</span><span class="token comment" spellcheck="true">// 列表缩进按shift+tab</span></code></pre><ul><li>目录1</li><li>目录2</li><li>目录3</li></ul><ol><li>首页</li><li>分类</li><li>标签</li></ol><h2 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h2><pre class=" language-java"><code class="language-java"><span class="token operator">|</span> 成绩 <span class="token operator">|</span> 语文 <span class="token operator">|</span> 数学 <span class="token operator">|</span><span class="token operator">|</span> <span class="token operator">--</span><span class="token operator">--</span> <span class="token operator">|</span> <span class="token operator">--</span><span class="token operator">--</span> <span class="token operator">|</span> <span class="token operator">--</span><span class="token operator">--</span> <span class="token operator">|</span><span class="token operator">|</span>      <span class="token operator">|</span> <span class="token number">78</span>   <span class="token operator">|</span> <span class="token number">90</span>   <span class="token operator">|</span></code></pre><table><thead><tr><th>成绩</th><th>语文</th><th>数学</th></tr></thead><tbody><tr><td></td><td>78</td><td>90</td></tr></tbody></table><p>推荐个好用的表格生成<a href="https://www.tablesgenerator.com/markdown_tables" target="_blank" rel="noopener">网站</a></p><h2 id="10、快捷键"><a href="#10、快捷键" class="headerlink" title="10、快捷键"></a>10、快捷键</h2><pre class=" language-xml"><code class="language-xml">Ctrl + / :    显示Typora源码Ctrl + shift + 1 :    大纲Ctrl + shift + 2 :    文档列表Ctrl + shift + 3 :    文件树Ctrl + shift + F :    搜索Ctrl + shift + L :    侧边栏</code></pre><h2 id="11、公式块"><a href="#11、公式块" class="headerlink" title="11、公式块"></a>11、公式块</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//行间公式</span>$$\sqrt<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>$$<span class="token comment" spellcheck="true">//行内公式:</span>$\sqrt<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span>$<span class="token comment" spellcheck="true">//公式编辑器</span>推荐使用Axmath国产公式编辑器，正版比Mathtype便宜，有能力的同学可以支持下正版还有一个在线公式编辑器，B站妈咪说MommyTalk出品，完全免费哟</code></pre><p>这是一个行间公式：<br>$$<br>\sqrt{2}<br>$$<br>这是一个行内公式：$\sqrt{3}$<br><a href="https://www.amyxun.com/" target="_blank" rel="noopener">Axmath下载</a></p><p><a href="https://www.latexlive.com/" target="_blank" rel="noopener">在线公式编辑器</a></p><h2 id="12、几种流程图"><a href="#12、几种流程图" class="headerlink" title="12、几种流程图"></a>12、几种流程图</h2><h4 id="1、横向流程图源码格式："><a href="#1、横向流程图源码格式：" class="headerlink" title="1、横向流程图源码格式："></a>1、横向流程图源码格式：</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mermaid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>graph LRA[方形] -->B(圆角)    B --> C{条件a}    C -->|a=1| D[结果1]    C -->|a=2| E[结果2]    F[横向流程图]<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span></code></pre><pre class="mermaid">graph LRA[方形] -->B(圆角)    B --> C{条件a}    C -->|a=1| D[结果1]    C -->|a=2| E[结果2]    F[横向流程图]</pre><h4 id="2、竖向流程图源码格式："><a href="#2、竖向流程图源码格式：" class="headerlink" title="2、竖向流程图源码格式："></a>2、竖向流程图源码格式：</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mermaid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>graph TDA[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    F[竖向流程图]<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span></code></pre><pre class="mermaid">graph TDA[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    F[竖向流程图]</pre><p><a href="https://www.runoob.com/markdown/md-advance.html" target="_blank" rel="noopener">流程图源码参考地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建报错问题总结</title>
      <link href="/2021/10/18/bo-ke-da-jian-bao-cuo-zong-jie/"/>
      <url>/2021/10/18/bo-ke-da-jian-bao-cuo-zong-jie/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="上传到云端出错"><a href="#上传到云端出错" class="headerlink" title="上传到云端出错"></a>上传到云端出错</h2><h2 id="提示1"><a href="#提示1" class="headerlink" title="提示1"></a>提示1</h2><p><code>hexo d</code>后提示</p><pre class=" language-java"><code class="language-java">To https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>gitee<span class="token punctuation">.</span>com<span class="token operator">/</span>DragonLanQAQ<span class="token operator">/</span>DragonLanQAQ<span class="token punctuation">.</span>git<span class="token operator">+</span>44bd99d<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">387e78f</span> HEAD <span class="token operator">-</span><span class="token operator">></span> <span class="token function">master</span> <span class="token punctuation">(</span>forced update<span class="token punctuation">)</span>Branch <span class="token string">'master'</span> set up to track remote branch <span class="token string">'master'</span> from <span class="token string">'https://gitee.com/DragonLanQAQ/DragonLanQAQ.git'</span><span class="token punctuation">.</span></code></pre><p>且页面未刷新</p><p>解决方案：删除 <code>.deploy_git</code>目录,再执行 <code>hexo d -g</code>就可以了</p><h2 id="提示2"><a href="#提示2" class="headerlink" title="提示2"></a>提示2</h2><p><code>hexo</code>从5.0降为4.2后，<code>hexo cl</code>后提示</p><pre class=" language-java"><code class="language-java">Plugin load failed<span class="token operator">:</span> hexo<span class="token operator">-</span>theme<span class="token operator">-</span>landscapeError<span class="token operator">:</span> EISDIR<span class="token operator">:</span> illegal operation on a directory<span class="token punctuation">,</span> read</code></pre><p>解决方案：</p><p>​        先执行</p><pre class=" language-java"><code class="language-java">grep <span class="token operator">-</span>rn <span class="token string">"hexo-theme-landscape"</span> </code></pre><p>​        再进入目录，把<code>hexo-theme-landscape</code>删了就行了</p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="提示3"><a href="#提示3" class="headerlink" title="提示3"></a>提示3</h2><p>Error: Spawn failed<br>    at ChildProcess.<anonymous> (C:\Users\Dragon_Lan\blog\node_modules\hexo-util\lib\spawn.js:51:21)<br>    at ChildProcess.emit (node:events:390:28)<br>    at ChildProcess.cp.emit (C:\Users\Dragon_Lan\blog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12)</p><h2 id="提示4"><a href="#提示4" class="headerlink" title="提示4"></a>提示4</h2><p>fatal: Could not set SSL backend to ‘openssl’: already set</p><h2 id="缓存："><a href="#缓存：" class="headerlink" title="缓存："></a>缓存：</h2><p>上传云端后图片未更改</p><p>解决方案：建议每次生成站点或部署之前都用 <code>hexo clean</code> 命令清理一下缓存，请使用<code>Ctrl + F5</code>清除缓存并刷新页面。</p><hr>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2021/10/18/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2021/10/18/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容测试</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codesheep.cn/" target="_blank" rel="noopener">www.codesheep.cn</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
